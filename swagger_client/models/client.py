# coding: utf-8

"""
    Administrative API Documentation

    The PingFederate Administrative API is a REST-based interface that provides a programmatic way to make configuration changes to PingFederate as an alternative to using the administrative console.<br/><br/>Expand the resources below to display implementation details on that resource such as the available endpoints, the parameter and response models for the operation, and the model structure of the resources themselves. Each resource operation comes with the ability to interact with the API. You are prompted for proper administration credentials when you try to perform an API operation.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class Client(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'client_id': 'str',
        'enabled': 'bool',
        'redirect_uris': 'list[str]',
        'grant_types': 'list[str]',
        'name': 'str',
        'description': 'str',
        'modification_date': 'datetime',
        'creation_date': 'datetime',
        'logo_url': 'str',
        'default_access_token_manager_ref': 'ResourceLink',
        'restrict_to_default_access_token_manager': 'bool',
        'validate_using_all_eligible_atms': 'bool',
        'refresh_rolling': 'str',
        'refresh_token_rolling_interval_type': 'str',
        'refresh_token_rolling_interval': 'int',
        'persistent_grant_expiration_type': 'str',
        'persistent_grant_expiration_time': 'int',
        'persistent_grant_expiration_time_unit': 'str',
        'persistent_grant_idle_timeout_type': 'str',
        'persistent_grant_idle_timeout': 'int',
        'persistent_grant_idle_timeout_time_unit': 'str',
        'persistent_grant_reuse_type': 'str',
        'persistent_grant_reuse_grant_types': 'list[str]',
        'allow_authentication_api_init': 'bool',
        'bypass_approval_page': 'bool',
        'restrict_scopes': 'bool',
        'restricted_scopes': 'list[str]',
        'exclusive_scopes': 'list[str]',
        'authorization_detail_types': 'list[str]',
        'restricted_response_types': 'list[str]',
        'require_pushed_authorization_requests': 'bool',
        'require_jwt_secured_authorization_response_mode': 'bool',
        'require_signed_requests': 'bool',
        'request_object_signing_algorithm': 'str',
        'oidc_policy': 'ClientOIDCPolicy',
        'client_auth': 'ClientAuth',
        'jwks_settings': 'JwksSettings',
        'extended_parameters': 'dict(str, ParameterValues)',
        'device_flow_setting_type': 'str',
        'user_authorization_url_override': 'str',
        'pending_authorization_timeout_override': 'int',
        'device_polling_interval_override': 'int',
        'bypass_activation_code_confirmation_override': 'bool',
        'require_proof_key_for_code_exchange': 'bool',
        'ciba_delivery_mode': 'str',
        'ciba_notification_endpoint': 'str',
        'ciba_polling_interval': 'int',
        'ciba_require_signed_requests': 'bool',
        'ciba_request_object_signing_algorithm': 'str',
        'ciba_user_code_supported': 'bool',
        'request_policy_ref': 'ResourceLink',
        'token_exchange_processor_policy_ref': 'ResourceLink',
        'refresh_token_rolling_grace_period_type': 'str',
        'refresh_token_rolling_grace_period': 'int',
        'client_secret_retention_period_type': 'str',
        'client_secret_retention_period': 'int',
        'client_secret_changed_time': 'datetime',
        'token_introspection_signing_algorithm': 'str',
        'token_introspection_encryption_algorithm': 'str',
        'token_introspection_content_encryption_algorithm': 'str',
        'jwt_secured_authorization_response_mode_signing_algorithm': 'str',
        'jwt_secured_authorization_response_mode_encryption_algorithm': 'str',
        'jwt_secured_authorization_response_mode_content_encryption_algorithm': 'str',
        'require_dpop': 'bool'
    }

    attribute_map = {
        'client_id': 'clientId',
        'enabled': 'enabled',
        'redirect_uris': 'redirectUris',
        'grant_types': 'grantTypes',
        'name': 'name',
        'description': 'description',
        'modification_date': 'modificationDate',
        'creation_date': 'creationDate',
        'logo_url': 'logoUrl',
        'default_access_token_manager_ref': 'defaultAccessTokenManagerRef',
        'restrict_to_default_access_token_manager': 'restrictToDefaultAccessTokenManager',
        'validate_using_all_eligible_atms': 'validateUsingAllEligibleAtms',
        'refresh_rolling': 'refreshRolling',
        'refresh_token_rolling_interval_type': 'refreshTokenRollingIntervalType',
        'refresh_token_rolling_interval': 'refreshTokenRollingInterval',
        'persistent_grant_expiration_type': 'persistentGrantExpirationType',
        'persistent_grant_expiration_time': 'persistentGrantExpirationTime',
        'persistent_grant_expiration_time_unit': 'persistentGrantExpirationTimeUnit',
        'persistent_grant_idle_timeout_type': 'persistentGrantIdleTimeoutType',
        'persistent_grant_idle_timeout': 'persistentGrantIdleTimeout',
        'persistent_grant_idle_timeout_time_unit': 'persistentGrantIdleTimeoutTimeUnit',
        'persistent_grant_reuse_type': 'persistentGrantReuseType',
        'persistent_grant_reuse_grant_types': 'persistentGrantReuseGrantTypes',
        'allow_authentication_api_init': 'allowAuthenticationApiInit',
        'bypass_approval_page': 'bypassApprovalPage',
        'restrict_scopes': 'restrictScopes',
        'restricted_scopes': 'restrictedScopes',
        'exclusive_scopes': 'exclusiveScopes',
        'authorization_detail_types': 'authorizationDetailTypes',
        'restricted_response_types': 'restrictedResponseTypes',
        'require_pushed_authorization_requests': 'requirePushedAuthorizationRequests',
        'require_jwt_secured_authorization_response_mode': 'requireJwtSecuredAuthorizationResponseMode',
        'require_signed_requests': 'requireSignedRequests',
        'request_object_signing_algorithm': 'requestObjectSigningAlgorithm',
        'oidc_policy': 'oidcPolicy',
        'client_auth': 'clientAuth',
        'jwks_settings': 'jwksSettings',
        'extended_parameters': 'extendedParameters',
        'device_flow_setting_type': 'deviceFlowSettingType',
        'user_authorization_url_override': 'userAuthorizationUrlOverride',
        'pending_authorization_timeout_override': 'pendingAuthorizationTimeoutOverride',
        'device_polling_interval_override': 'devicePollingIntervalOverride',
        'bypass_activation_code_confirmation_override': 'bypassActivationCodeConfirmationOverride',
        'require_proof_key_for_code_exchange': 'requireProofKeyForCodeExchange',
        'ciba_delivery_mode': 'cibaDeliveryMode',
        'ciba_notification_endpoint': 'cibaNotificationEndpoint',
        'ciba_polling_interval': 'cibaPollingInterval',
        'ciba_require_signed_requests': 'cibaRequireSignedRequests',
        'ciba_request_object_signing_algorithm': 'cibaRequestObjectSigningAlgorithm',
        'ciba_user_code_supported': 'cibaUserCodeSupported',
        'request_policy_ref': 'requestPolicyRef',
        'token_exchange_processor_policy_ref': 'tokenExchangeProcessorPolicyRef',
        'refresh_token_rolling_grace_period_type': 'refreshTokenRollingGracePeriodType',
        'refresh_token_rolling_grace_period': 'refreshTokenRollingGracePeriod',
        'client_secret_retention_period_type': 'clientSecretRetentionPeriodType',
        'client_secret_retention_period': 'clientSecretRetentionPeriod',
        'client_secret_changed_time': 'clientSecretChangedTime',
        'token_introspection_signing_algorithm': 'tokenIntrospectionSigningAlgorithm',
        'token_introspection_encryption_algorithm': 'tokenIntrospectionEncryptionAlgorithm',
        'token_introspection_content_encryption_algorithm': 'tokenIntrospectionContentEncryptionAlgorithm',
        'jwt_secured_authorization_response_mode_signing_algorithm': 'jwtSecuredAuthorizationResponseModeSigningAlgorithm',
        'jwt_secured_authorization_response_mode_encryption_algorithm': 'jwtSecuredAuthorizationResponseModeEncryptionAlgorithm',
        'jwt_secured_authorization_response_mode_content_encryption_algorithm': 'jwtSecuredAuthorizationResponseModeContentEncryptionAlgorithm',
        'require_dpop': 'requireDpop'
    }

    def __init__(self, client_id=None, enabled=None, redirect_uris=None, grant_types=None, name=None, description=None, modification_date=None, creation_date=None, logo_url=None, default_access_token_manager_ref=None, restrict_to_default_access_token_manager=None, validate_using_all_eligible_atms=None, refresh_rolling=None, refresh_token_rolling_interval_type=None, refresh_token_rolling_interval=None, persistent_grant_expiration_type=None, persistent_grant_expiration_time=None, persistent_grant_expiration_time_unit=None, persistent_grant_idle_timeout_type=None, persistent_grant_idle_timeout=None, persistent_grant_idle_timeout_time_unit=None, persistent_grant_reuse_type=None, persistent_grant_reuse_grant_types=None, allow_authentication_api_init=None, bypass_approval_page=None, restrict_scopes=None, restricted_scopes=None, exclusive_scopes=None, authorization_detail_types=None, restricted_response_types=None, require_pushed_authorization_requests=None, require_jwt_secured_authorization_response_mode=None, require_signed_requests=None, request_object_signing_algorithm=None, oidc_policy=None, client_auth=None, jwks_settings=None, extended_parameters=None, device_flow_setting_type=None, user_authorization_url_override=None, pending_authorization_timeout_override=None, device_polling_interval_override=None, bypass_activation_code_confirmation_override=None, require_proof_key_for_code_exchange=None, ciba_delivery_mode=None, ciba_notification_endpoint=None, ciba_polling_interval=None, ciba_require_signed_requests=None, ciba_request_object_signing_algorithm=None, ciba_user_code_supported=None, request_policy_ref=None, token_exchange_processor_policy_ref=None, refresh_token_rolling_grace_period_type=None, refresh_token_rolling_grace_period=None, client_secret_retention_period_type=None, client_secret_retention_period=None, client_secret_changed_time=None, token_introspection_signing_algorithm=None, token_introspection_encryption_algorithm=None, token_introspection_content_encryption_algorithm=None, jwt_secured_authorization_response_mode_signing_algorithm=None, jwt_secured_authorization_response_mode_encryption_algorithm=None, jwt_secured_authorization_response_mode_content_encryption_algorithm=None, require_dpop=None, _configuration=None):  # noqa: E501
        """Client - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._client_id = None
        self._enabled = None
        self._redirect_uris = None
        self._grant_types = None
        self._name = None
        self._description = None
        self._modification_date = None
        self._creation_date = None
        self._logo_url = None
        self._default_access_token_manager_ref = None
        self._restrict_to_default_access_token_manager = None
        self._validate_using_all_eligible_atms = None
        self._refresh_rolling = None
        self._refresh_token_rolling_interval_type = None
        self._refresh_token_rolling_interval = None
        self._persistent_grant_expiration_type = None
        self._persistent_grant_expiration_time = None
        self._persistent_grant_expiration_time_unit = None
        self._persistent_grant_idle_timeout_type = None
        self._persistent_grant_idle_timeout = None
        self._persistent_grant_idle_timeout_time_unit = None
        self._persistent_grant_reuse_type = None
        self._persistent_grant_reuse_grant_types = None
        self._allow_authentication_api_init = None
        self._bypass_approval_page = None
        self._restrict_scopes = None
        self._restricted_scopes = None
        self._exclusive_scopes = None
        self._authorization_detail_types = None
        self._restricted_response_types = None
        self._require_pushed_authorization_requests = None
        self._require_jwt_secured_authorization_response_mode = None
        self._require_signed_requests = None
        self._request_object_signing_algorithm = None
        self._oidc_policy = None
        self._client_auth = None
        self._jwks_settings = None
        self._extended_parameters = None
        self._device_flow_setting_type = None
        self._user_authorization_url_override = None
        self._pending_authorization_timeout_override = None
        self._device_polling_interval_override = None
        self._bypass_activation_code_confirmation_override = None
        self._require_proof_key_for_code_exchange = None
        self._ciba_delivery_mode = None
        self._ciba_notification_endpoint = None
        self._ciba_polling_interval = None
        self._ciba_require_signed_requests = None
        self._ciba_request_object_signing_algorithm = None
        self._ciba_user_code_supported = None
        self._request_policy_ref = None
        self._token_exchange_processor_policy_ref = None
        self._refresh_token_rolling_grace_period_type = None
        self._refresh_token_rolling_grace_period = None
        self._client_secret_retention_period_type = None
        self._client_secret_retention_period = None
        self._client_secret_changed_time = None
        self._token_introspection_signing_algorithm = None
        self._token_introspection_encryption_algorithm = None
        self._token_introspection_content_encryption_algorithm = None
        self._jwt_secured_authorization_response_mode_signing_algorithm = None
        self._jwt_secured_authorization_response_mode_encryption_algorithm = None
        self._jwt_secured_authorization_response_mode_content_encryption_algorithm = None
        self._require_dpop = None
        self.discriminator = None

        self.client_id = client_id
        if enabled is not None:
            self.enabled = enabled
        if redirect_uris is not None:
            self.redirect_uris = redirect_uris
        self.grant_types = grant_types
        self.name = name
        if description is not None:
            self.description = description
        if modification_date is not None:
            self.modification_date = modification_date
        if creation_date is not None:
            self.creation_date = creation_date
        if logo_url is not None:
            self.logo_url = logo_url
        if default_access_token_manager_ref is not None:
            self.default_access_token_manager_ref = default_access_token_manager_ref
        if restrict_to_default_access_token_manager is not None:
            self.restrict_to_default_access_token_manager = restrict_to_default_access_token_manager
        if validate_using_all_eligible_atms is not None:
            self.validate_using_all_eligible_atms = validate_using_all_eligible_atms
        if refresh_rolling is not None:
            self.refresh_rolling = refresh_rolling
        if refresh_token_rolling_interval_type is not None:
            self.refresh_token_rolling_interval_type = refresh_token_rolling_interval_type
        if refresh_token_rolling_interval is not None:
            self.refresh_token_rolling_interval = refresh_token_rolling_interval
        if persistent_grant_expiration_type is not None:
            self.persistent_grant_expiration_type = persistent_grant_expiration_type
        if persistent_grant_expiration_time is not None:
            self.persistent_grant_expiration_time = persistent_grant_expiration_time
        if persistent_grant_expiration_time_unit is not None:
            self.persistent_grant_expiration_time_unit = persistent_grant_expiration_time_unit
        if persistent_grant_idle_timeout_type is not None:
            self.persistent_grant_idle_timeout_type = persistent_grant_idle_timeout_type
        if persistent_grant_idle_timeout is not None:
            self.persistent_grant_idle_timeout = persistent_grant_idle_timeout
        if persistent_grant_idle_timeout_time_unit is not None:
            self.persistent_grant_idle_timeout_time_unit = persistent_grant_idle_timeout_time_unit
        if persistent_grant_reuse_type is not None:
            self.persistent_grant_reuse_type = persistent_grant_reuse_type
        if persistent_grant_reuse_grant_types is not None:
            self.persistent_grant_reuse_grant_types = persistent_grant_reuse_grant_types
        if allow_authentication_api_init is not None:
            self.allow_authentication_api_init = allow_authentication_api_init
        if bypass_approval_page is not None:
            self.bypass_approval_page = bypass_approval_page
        if restrict_scopes is not None:
            self.restrict_scopes = restrict_scopes
        if restricted_scopes is not None:
            self.restricted_scopes = restricted_scopes
        if exclusive_scopes is not None:
            self.exclusive_scopes = exclusive_scopes
        if authorization_detail_types is not None:
            self.authorization_detail_types = authorization_detail_types
        if restricted_response_types is not None:
            self.restricted_response_types = restricted_response_types
        if require_pushed_authorization_requests is not None:
            self.require_pushed_authorization_requests = require_pushed_authorization_requests
        if require_jwt_secured_authorization_response_mode is not None:
            self.require_jwt_secured_authorization_response_mode = require_jwt_secured_authorization_response_mode
        if require_signed_requests is not None:
            self.require_signed_requests = require_signed_requests
        if request_object_signing_algorithm is not None:
            self.request_object_signing_algorithm = request_object_signing_algorithm
        if oidc_policy is not None:
            self.oidc_policy = oidc_policy
        if client_auth is not None:
            self.client_auth = client_auth
        if jwks_settings is not None:
            self.jwks_settings = jwks_settings
        if extended_parameters is not None:
            self.extended_parameters = extended_parameters
        if device_flow_setting_type is not None:
            self.device_flow_setting_type = device_flow_setting_type
        if user_authorization_url_override is not None:
            self.user_authorization_url_override = user_authorization_url_override
        if pending_authorization_timeout_override is not None:
            self.pending_authorization_timeout_override = pending_authorization_timeout_override
        if device_polling_interval_override is not None:
            self.device_polling_interval_override = device_polling_interval_override
        if bypass_activation_code_confirmation_override is not None:
            self.bypass_activation_code_confirmation_override = bypass_activation_code_confirmation_override
        if require_proof_key_for_code_exchange is not None:
            self.require_proof_key_for_code_exchange = require_proof_key_for_code_exchange
        if ciba_delivery_mode is not None:
            self.ciba_delivery_mode = ciba_delivery_mode
        if ciba_notification_endpoint is not None:
            self.ciba_notification_endpoint = ciba_notification_endpoint
        if ciba_polling_interval is not None:
            self.ciba_polling_interval = ciba_polling_interval
        if ciba_require_signed_requests is not None:
            self.ciba_require_signed_requests = ciba_require_signed_requests
        if ciba_request_object_signing_algorithm is not None:
            self.ciba_request_object_signing_algorithm = ciba_request_object_signing_algorithm
        if ciba_user_code_supported is not None:
            self.ciba_user_code_supported = ciba_user_code_supported
        if request_policy_ref is not None:
            self.request_policy_ref = request_policy_ref
        if token_exchange_processor_policy_ref is not None:
            self.token_exchange_processor_policy_ref = token_exchange_processor_policy_ref
        if refresh_token_rolling_grace_period_type is not None:
            self.refresh_token_rolling_grace_period_type = refresh_token_rolling_grace_period_type
        if refresh_token_rolling_grace_period is not None:
            self.refresh_token_rolling_grace_period = refresh_token_rolling_grace_period
        if client_secret_retention_period_type is not None:
            self.client_secret_retention_period_type = client_secret_retention_period_type
        if client_secret_retention_period is not None:
            self.client_secret_retention_period = client_secret_retention_period
        if client_secret_changed_time is not None:
            self.client_secret_changed_time = client_secret_changed_time
        if token_introspection_signing_algorithm is not None:
            self.token_introspection_signing_algorithm = token_introspection_signing_algorithm
        if token_introspection_encryption_algorithm is not None:
            self.token_introspection_encryption_algorithm = token_introspection_encryption_algorithm
        if token_introspection_content_encryption_algorithm is not None:
            self.token_introspection_content_encryption_algorithm = token_introspection_content_encryption_algorithm
        if jwt_secured_authorization_response_mode_signing_algorithm is not None:
            self.jwt_secured_authorization_response_mode_signing_algorithm = jwt_secured_authorization_response_mode_signing_algorithm
        if jwt_secured_authorization_response_mode_encryption_algorithm is not None:
            self.jwt_secured_authorization_response_mode_encryption_algorithm = jwt_secured_authorization_response_mode_encryption_algorithm
        if jwt_secured_authorization_response_mode_content_encryption_algorithm is not None:
            self.jwt_secured_authorization_response_mode_content_encryption_algorithm = jwt_secured_authorization_response_mode_content_encryption_algorithm
        if require_dpop is not None:
            self.require_dpop = require_dpop

    @property
    def client_id(self):
        """Gets the client_id of this Client.  # noqa: E501

        A unique identifier the client provides to the Resource Server to identify itself. This identifier is included with every request the client makes. For PUT requests, this field is optional and it will be overridden by the 'id' parameter of the PUT request.  # noqa: E501

        :return: The client_id of this Client.  # noqa: E501
        :rtype: str
        """
        return self._client_id

    @client_id.setter
    def client_id(self, client_id):
        """Sets the client_id of this Client.

        A unique identifier the client provides to the Resource Server to identify itself. This identifier is included with every request the client makes. For PUT requests, this field is optional and it will be overridden by the 'id' parameter of the PUT request.  # noqa: E501

        :param client_id: The client_id of this Client.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and client_id is None:
            raise ValueError("Invalid value for `client_id`, must not be `None`")  # noqa: E501

        self._client_id = client_id

    @property
    def enabled(self):
        """Gets the enabled of this Client.  # noqa: E501

        Specifies whether the client is enabled. The default value is true.  # noqa: E501

        :return: The enabled of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._enabled

    @enabled.setter
    def enabled(self, enabled):
        """Sets the enabled of this Client.

        Specifies whether the client is enabled. The default value is true.  # noqa: E501

        :param enabled: The enabled of this Client.  # noqa: E501
        :type: bool
        """

        self._enabled = enabled

    @property
    def redirect_uris(self):
        """Gets the redirect_uris of this Client.  # noqa: E501

        URIs to which the OAuth AS may redirect the resource owner's user agent after authorization is obtained. A redirection URI is used with the Authorization Code and Implicit grant types. Wildcards are allowed. However, for security reasons, make the URL as restrictive as possible.For example: https://*.company.com/* Important: If more than one URI is added or if a single URI uses wildcards, then Authorization Code grant and token requests must contain a specific matching redirect uri parameter.  # noqa: E501

        :return: The redirect_uris of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._redirect_uris

    @redirect_uris.setter
    def redirect_uris(self, redirect_uris):
        """Sets the redirect_uris of this Client.

        URIs to which the OAuth AS may redirect the resource owner's user agent after authorization is obtained. A redirection URI is used with the Authorization Code and Implicit grant types. Wildcards are allowed. However, for security reasons, make the URL as restrictive as possible.For example: https://*.company.com/* Important: If more than one URI is added or if a single URI uses wildcards, then Authorization Code grant and token requests must contain a specific matching redirect uri parameter.  # noqa: E501

        :param redirect_uris: The redirect_uris of this Client.  # noqa: E501
        :type: list[str]
        """

        self._redirect_uris = redirect_uris

    @property
    def grant_types(self):
        """Gets the grant_types of this Client.  # noqa: E501

        The grant types allowed for this client. The EXTENSION grant type applies to SAML/JWT assertion grants.  # noqa: E501

        :return: The grant_types of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._grant_types

    @grant_types.setter
    def grant_types(self, grant_types):
        """Sets the grant_types of this Client.

        The grant types allowed for this client. The EXTENSION grant type applies to SAML/JWT assertion grants.  # noqa: E501

        :param grant_types: The grant_types of this Client.  # noqa: E501
        :type: list[str]
        """
        if self._configuration.client_side_validation and grant_types is None:
            raise ValueError("Invalid value for `grant_types`, must not be `None`")  # noqa: E501
        allowed_values = ["IMPLICIT", "AUTHORIZATION_CODE", "RESOURCE_OWNER_CREDENTIALS", "CLIENT_CREDENTIALS", "REFRESH_TOKEN", "EXTENSION", "DEVICE_CODE", "ACCESS_TOKEN_VALIDATION", "CIBA", "TOKEN_EXCHANGE"]  # noqa: E501
        if (self._configuration.client_side_validation and
                not set(grant_types).issubset(set(allowed_values))):  # noqa: E501
            raise ValueError(
                "Invalid values for `grant_types` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(grant_types) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._grant_types = grant_types

    @property
    def name(self):
        """Gets the name of this Client.  # noqa: E501

        A descriptive name for the client instance. This name appears when the user is prompted for authorization.  # noqa: E501

        :return: The name of this Client.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this Client.

        A descriptive name for the client instance. This name appears when the user is prompted for authorization.  # noqa: E501

        :param name: The name of this Client.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    @property
    def description(self):
        """Gets the description of this Client.  # noqa: E501

        A description of what the client application does. This description appears when the user is prompted for authorization.  # noqa: E501

        :return: The description of this Client.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this Client.

        A description of what the client application does. This description appears when the user is prompted for authorization.  # noqa: E501

        :param description: The description of this Client.  # noqa: E501
        :type: str
        """

        self._description = description

    @property
    def modification_date(self):
        """Gets the modification_date of this Client.  # noqa: E501

        The time at which the client was last changed. This property is read only and is ignored on PUT and POST requests.  # noqa: E501

        :return: The modification_date of this Client.  # noqa: E501
        :rtype: datetime
        """
        return self._modification_date

    @modification_date.setter
    def modification_date(self, modification_date):
        """Sets the modification_date of this Client.

        The time at which the client was last changed. This property is read only and is ignored on PUT and POST requests.  # noqa: E501

        :param modification_date: The modification_date of this Client.  # noqa: E501
        :type: datetime
        """

        self._modification_date = modification_date

    @property
    def creation_date(self):
        """Gets the creation_date of this Client.  # noqa: E501

        The time at which the client was created. This property is read only and is ignored on PUT and POST requests.  # noqa: E501

        :return: The creation_date of this Client.  # noqa: E501
        :rtype: datetime
        """
        return self._creation_date

    @creation_date.setter
    def creation_date(self, creation_date):
        """Sets the creation_date of this Client.

        The time at which the client was created. This property is read only and is ignored on PUT and POST requests.  # noqa: E501

        :param creation_date: The creation_date of this Client.  # noqa: E501
        :type: datetime
        """

        self._creation_date = creation_date

    @property
    def logo_url(self):
        """Gets the logo_url of this Client.  # noqa: E501

        The location of the logo used on user-facing OAuth grant authorization and revocation pages.  # noqa: E501

        :return: The logo_url of this Client.  # noqa: E501
        :rtype: str
        """
        return self._logo_url

    @logo_url.setter
    def logo_url(self, logo_url):
        """Sets the logo_url of this Client.

        The location of the logo used on user-facing OAuth grant authorization and revocation pages.  # noqa: E501

        :param logo_url: The logo_url of this Client.  # noqa: E501
        :type: str
        """

        self._logo_url = logo_url

    @property
    def default_access_token_manager_ref(self):
        """Gets the default_access_token_manager_ref of this Client.  # noqa: E501

        The default access token manager for this client.  # noqa: E501

        :return: The default_access_token_manager_ref of this Client.  # noqa: E501
        :rtype: ResourceLink
        """
        return self._default_access_token_manager_ref

    @default_access_token_manager_ref.setter
    def default_access_token_manager_ref(self, default_access_token_manager_ref):
        """Sets the default_access_token_manager_ref of this Client.

        The default access token manager for this client.  # noqa: E501

        :param default_access_token_manager_ref: The default_access_token_manager_ref of this Client.  # noqa: E501
        :type: ResourceLink
        """

        self._default_access_token_manager_ref = default_access_token_manager_ref

    @property
    def restrict_to_default_access_token_manager(self):
        """Gets the restrict_to_default_access_token_manager of this Client.  # noqa: E501

        Determines whether the client is restricted to using only its default access token manager. The default is false.  # noqa: E501

        :return: The restrict_to_default_access_token_manager of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._restrict_to_default_access_token_manager

    @restrict_to_default_access_token_manager.setter
    def restrict_to_default_access_token_manager(self, restrict_to_default_access_token_manager):
        """Sets the restrict_to_default_access_token_manager of this Client.

        Determines whether the client is restricted to using only its default access token manager. The default is false.  # noqa: E501

        :param restrict_to_default_access_token_manager: The restrict_to_default_access_token_manager of this Client.  # noqa: E501
        :type: bool
        """

        self._restrict_to_default_access_token_manager = restrict_to_default_access_token_manager

    @property
    def validate_using_all_eligible_atms(self):
        """Gets the validate_using_all_eligible_atms of this Client.  # noqa: E501

        Validates token using all eligible access token managers for the client. This setting is ignored if 'restrictToDefaultAccessTokenManager' is set to true.  # noqa: E501

        :return: The validate_using_all_eligible_atms of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._validate_using_all_eligible_atms

    @validate_using_all_eligible_atms.setter
    def validate_using_all_eligible_atms(self, validate_using_all_eligible_atms):
        """Sets the validate_using_all_eligible_atms of this Client.

        Validates token using all eligible access token managers for the client. This setting is ignored if 'restrictToDefaultAccessTokenManager' is set to true.  # noqa: E501

        :param validate_using_all_eligible_atms: The validate_using_all_eligible_atms of this Client.  # noqa: E501
        :type: bool
        """

        self._validate_using_all_eligible_atms = validate_using_all_eligible_atms

    @property
    def refresh_rolling(self):
        """Gets the refresh_rolling of this Client.  # noqa: E501

        Use ROLL or DONT_ROLL to override the Roll Refresh Token Values setting on the Authorization Server Settings. SERVER_DEFAULT will default to the Roll Refresh Token Values setting on the Authorization Server Setting screen. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The refresh_rolling of this Client.  # noqa: E501
        :rtype: str
        """
        return self._refresh_rolling

    @refresh_rolling.setter
    def refresh_rolling(self, refresh_rolling):
        """Sets the refresh_rolling of this Client.

        Use ROLL or DONT_ROLL to override the Roll Refresh Token Values setting on the Authorization Server Settings. SERVER_DEFAULT will default to the Roll Refresh Token Values setting on the Authorization Server Setting screen. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param refresh_rolling: The refresh_rolling of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["SERVER_DEFAULT", "DONT_ROLL", "ROLL"]  # noqa: E501
        if (self._configuration.client_side_validation and
                refresh_rolling not in allowed_values):
            raise ValueError(
                "Invalid value for `refresh_rolling` ({0}), must be one of {1}"  # noqa: E501
                .format(refresh_rolling, allowed_values)
            )

        self._refresh_rolling = refresh_rolling

    @property
    def refresh_token_rolling_interval_type(self):
        """Gets the refresh_token_rolling_interval_type of this Client.  # noqa: E501

        Use OVERRIDE_SERVER_DEFAULT to override the Refresh Token Rolling Interval value on the Authorization Server Settings. SERVER_DEFAULT will default to the Refresh Token Rolling Interval value on the Authorization Server Setting. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The refresh_token_rolling_interval_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._refresh_token_rolling_interval_type

    @refresh_token_rolling_interval_type.setter
    def refresh_token_rolling_interval_type(self, refresh_token_rolling_interval_type):
        """Sets the refresh_token_rolling_interval_type of this Client.

        Use OVERRIDE_SERVER_DEFAULT to override the Refresh Token Rolling Interval value on the Authorization Server Settings. SERVER_DEFAULT will default to the Refresh Token Rolling Interval value on the Authorization Server Setting. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param refresh_token_rolling_interval_type: The refresh_token_rolling_interval_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                refresh_token_rolling_interval_type not in allowed_values):
            raise ValueError(
                "Invalid value for `refresh_token_rolling_interval_type` ({0}), must be one of {1}"  # noqa: E501
                .format(refresh_token_rolling_interval_type, allowed_values)
            )

        self._refresh_token_rolling_interval_type = refresh_token_rolling_interval_type

    @property
    def refresh_token_rolling_interval(self):
        """Gets the refresh_token_rolling_interval of this Client.  # noqa: E501

        The minimum interval to roll refresh tokens, in hours. This value will override the Refresh Token Rolling Interval Value on the Authorization Server Settings.  # noqa: E501

        :return: The refresh_token_rolling_interval of this Client.  # noqa: E501
        :rtype: int
        """
        return self._refresh_token_rolling_interval

    @refresh_token_rolling_interval.setter
    def refresh_token_rolling_interval(self, refresh_token_rolling_interval):
        """Sets the refresh_token_rolling_interval of this Client.

        The minimum interval to roll refresh tokens, in hours. This value will override the Refresh Token Rolling Interval Value on the Authorization Server Settings.  # noqa: E501

        :param refresh_token_rolling_interval: The refresh_token_rolling_interval of this Client.  # noqa: E501
        :type: int
        """

        self._refresh_token_rolling_interval = refresh_token_rolling_interval

    @property
    def persistent_grant_expiration_type(self):
        """Gets the persistent_grant_expiration_type of this Client.  # noqa: E501

        Allows an administrator to override the Persistent Grant Lifetime set globally for the OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The persistent_grant_expiration_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._persistent_grant_expiration_type

    @persistent_grant_expiration_type.setter
    def persistent_grant_expiration_type(self, persistent_grant_expiration_type):
        """Sets the persistent_grant_expiration_type of this Client.

        Allows an administrator to override the Persistent Grant Lifetime set globally for the OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param persistent_grant_expiration_type: The persistent_grant_expiration_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["INDEFINITE_EXPIRY", "SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                persistent_grant_expiration_type not in allowed_values):
            raise ValueError(
                "Invalid value for `persistent_grant_expiration_type` ({0}), must be one of {1}"  # noqa: E501
                .format(persistent_grant_expiration_type, allowed_values)
            )

        self._persistent_grant_expiration_type = persistent_grant_expiration_type

    @property
    def persistent_grant_expiration_time(self):
        """Gets the persistent_grant_expiration_time of this Client.  # noqa: E501

        The persistent grant expiration time. -1 indicates an indefinite amount of time.  # noqa: E501

        :return: The persistent_grant_expiration_time of this Client.  # noqa: E501
        :rtype: int
        """
        return self._persistent_grant_expiration_time

    @persistent_grant_expiration_time.setter
    def persistent_grant_expiration_time(self, persistent_grant_expiration_time):
        """Sets the persistent_grant_expiration_time of this Client.

        The persistent grant expiration time. -1 indicates an indefinite amount of time.  # noqa: E501

        :param persistent_grant_expiration_time: The persistent_grant_expiration_time of this Client.  # noqa: E501
        :type: int
        """

        self._persistent_grant_expiration_time = persistent_grant_expiration_time

    @property
    def persistent_grant_expiration_time_unit(self):
        """Gets the persistent_grant_expiration_time_unit of this Client.  # noqa: E501

        The persistent grant expiration time unit.  # noqa: E501

        :return: The persistent_grant_expiration_time_unit of this Client.  # noqa: E501
        :rtype: str
        """
        return self._persistent_grant_expiration_time_unit

    @persistent_grant_expiration_time_unit.setter
    def persistent_grant_expiration_time_unit(self, persistent_grant_expiration_time_unit):
        """Sets the persistent_grant_expiration_time_unit of this Client.

        The persistent grant expiration time unit.  # noqa: E501

        :param persistent_grant_expiration_time_unit: The persistent_grant_expiration_time_unit of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["MINUTES", "DAYS", "HOURS"]  # noqa: E501
        if (self._configuration.client_side_validation and
                persistent_grant_expiration_time_unit not in allowed_values):
            raise ValueError(
                "Invalid value for `persistent_grant_expiration_time_unit` ({0}), must be one of {1}"  # noqa: E501
                .format(persistent_grant_expiration_time_unit, allowed_values)
            )

        self._persistent_grant_expiration_time_unit = persistent_grant_expiration_time_unit

    @property
    def persistent_grant_idle_timeout_type(self):
        """Gets the persistent_grant_idle_timeout_type of this Client.  # noqa: E501

        Allows an administrator to override the Persistent Grant Idle Timeout set globally for the OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The persistent_grant_idle_timeout_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._persistent_grant_idle_timeout_type

    @persistent_grant_idle_timeout_type.setter
    def persistent_grant_idle_timeout_type(self, persistent_grant_idle_timeout_type):
        """Sets the persistent_grant_idle_timeout_type of this Client.

        Allows an administrator to override the Persistent Grant Idle Timeout set globally for the OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param persistent_grant_idle_timeout_type: The persistent_grant_idle_timeout_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["INDEFINITE_EXPIRY", "SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                persistent_grant_idle_timeout_type not in allowed_values):
            raise ValueError(
                "Invalid value for `persistent_grant_idle_timeout_type` ({0}), must be one of {1}"  # noqa: E501
                .format(persistent_grant_idle_timeout_type, allowed_values)
            )

        self._persistent_grant_idle_timeout_type = persistent_grant_idle_timeout_type

    @property
    def persistent_grant_idle_timeout(self):
        """Gets the persistent_grant_idle_timeout of this Client.  # noqa: E501

        The persistent grant idle timeout.  # noqa: E501

        :return: The persistent_grant_idle_timeout of this Client.  # noqa: E501
        :rtype: int
        """
        return self._persistent_grant_idle_timeout

    @persistent_grant_idle_timeout.setter
    def persistent_grant_idle_timeout(self, persistent_grant_idle_timeout):
        """Sets the persistent_grant_idle_timeout of this Client.

        The persistent grant idle timeout.  # noqa: E501

        :param persistent_grant_idle_timeout: The persistent_grant_idle_timeout of this Client.  # noqa: E501
        :type: int
        """

        self._persistent_grant_idle_timeout = persistent_grant_idle_timeout

    @property
    def persistent_grant_idle_timeout_time_unit(self):
        """Gets the persistent_grant_idle_timeout_time_unit of this Client.  # noqa: E501

        The persistent grant idle timeout time unit.  # noqa: E501

        :return: The persistent_grant_idle_timeout_time_unit of this Client.  # noqa: E501
        :rtype: str
        """
        return self._persistent_grant_idle_timeout_time_unit

    @persistent_grant_idle_timeout_time_unit.setter
    def persistent_grant_idle_timeout_time_unit(self, persistent_grant_idle_timeout_time_unit):
        """Sets the persistent_grant_idle_timeout_time_unit of this Client.

        The persistent grant idle timeout time unit.  # noqa: E501

        :param persistent_grant_idle_timeout_time_unit: The persistent_grant_idle_timeout_time_unit of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["MINUTES", "DAYS", "HOURS"]  # noqa: E501
        if (self._configuration.client_side_validation and
                persistent_grant_idle_timeout_time_unit not in allowed_values):
            raise ValueError(
                "Invalid value for `persistent_grant_idle_timeout_time_unit` ({0}), must be one of {1}"  # noqa: E501
                .format(persistent_grant_idle_timeout_time_unit, allowed_values)
            )

        self._persistent_grant_idle_timeout_time_unit = persistent_grant_idle_timeout_time_unit

    @property
    def persistent_grant_reuse_type(self):
        """Gets the persistent_grant_reuse_type of this Client.  # noqa: E501

        Allows and administrator to override the Reuse Existing Persistent Access Grants for Grant Types set globally for OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The persistent_grant_reuse_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._persistent_grant_reuse_type

    @persistent_grant_reuse_type.setter
    def persistent_grant_reuse_type(self, persistent_grant_reuse_type):
        """Sets the persistent_grant_reuse_type of this Client.

        Allows and administrator to override the Reuse Existing Persistent Access Grants for Grant Types set globally for OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param persistent_grant_reuse_type: The persistent_grant_reuse_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                persistent_grant_reuse_type not in allowed_values):
            raise ValueError(
                "Invalid value for `persistent_grant_reuse_type` ({0}), must be one of {1}"  # noqa: E501
                .format(persistent_grant_reuse_type, allowed_values)
            )

        self._persistent_grant_reuse_type = persistent_grant_reuse_type

    @property
    def persistent_grant_reuse_grant_types(self):
        """Gets the persistent_grant_reuse_grant_types of this Client.  # noqa: E501

        The grant types that the OAuth AS can reuse rather than creating a new grant for each request. This value will override the Reuse Existing Persistent Access Grants for Grant Types on the Authorization Server Settings. Only 'IMPLICIT' or 'AUTHORIZATION_CODE' or 'RESOURCE_OWNER_CREDENTIALS' are valid grant types.  # noqa: E501

        :return: The persistent_grant_reuse_grant_types of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._persistent_grant_reuse_grant_types

    @persistent_grant_reuse_grant_types.setter
    def persistent_grant_reuse_grant_types(self, persistent_grant_reuse_grant_types):
        """Sets the persistent_grant_reuse_grant_types of this Client.

        The grant types that the OAuth AS can reuse rather than creating a new grant for each request. This value will override the Reuse Existing Persistent Access Grants for Grant Types on the Authorization Server Settings. Only 'IMPLICIT' or 'AUTHORIZATION_CODE' or 'RESOURCE_OWNER_CREDENTIALS' are valid grant types.  # noqa: E501

        :param persistent_grant_reuse_grant_types: The persistent_grant_reuse_grant_types of this Client.  # noqa: E501
        :type: list[str]
        """
        allowed_values = ["IMPLICIT", "AUTHORIZATION_CODE", "RESOURCE_OWNER_CREDENTIALS", "CLIENT_CREDENTIALS", "REFRESH_TOKEN", "EXTENSION", "DEVICE_CODE", "ACCESS_TOKEN_VALIDATION", "CIBA", "TOKEN_EXCHANGE"]  # noqa: E501
        if (self._configuration.client_side_validation and
                not set(persistent_grant_reuse_grant_types).issubset(set(allowed_values))):  # noqa: E501
            raise ValueError(
                "Invalid values for `persistent_grant_reuse_grant_types` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set(persistent_grant_reuse_grant_types) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )

        self._persistent_grant_reuse_grant_types = persistent_grant_reuse_grant_types

    @property
    def allow_authentication_api_init(self):
        """Gets the allow_authentication_api_init of this Client.  # noqa: E501

        Set to true to allow this client to initiate the authentication API redirectless flow.  # noqa: E501

        :return: The allow_authentication_api_init of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._allow_authentication_api_init

    @allow_authentication_api_init.setter
    def allow_authentication_api_init(self, allow_authentication_api_init):
        """Sets the allow_authentication_api_init of this Client.

        Set to true to allow this client to initiate the authentication API redirectless flow.  # noqa: E501

        :param allow_authentication_api_init: The allow_authentication_api_init of this Client.  # noqa: E501
        :type: bool
        """

        self._allow_authentication_api_init = allow_authentication_api_init

    @property
    def bypass_approval_page(self):
        """Gets the bypass_approval_page of this Client.  # noqa: E501

        Use this setting, for example, when you want to deploy a trusted application and authenticate end users via an IdP adapter or IdP connection.  # noqa: E501

        :return: The bypass_approval_page of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._bypass_approval_page

    @bypass_approval_page.setter
    def bypass_approval_page(self, bypass_approval_page):
        """Sets the bypass_approval_page of this Client.

        Use this setting, for example, when you want to deploy a trusted application and authenticate end users via an IdP adapter or IdP connection.  # noqa: E501

        :param bypass_approval_page: The bypass_approval_page of this Client.  # noqa: E501
        :type: bool
        """

        self._bypass_approval_page = bypass_approval_page

    @property
    def restrict_scopes(self):
        """Gets the restrict_scopes of this Client.  # noqa: E501

        Restricts this client's access to specific scopes.  # noqa: E501

        :return: The restrict_scopes of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._restrict_scopes

    @restrict_scopes.setter
    def restrict_scopes(self, restrict_scopes):
        """Sets the restrict_scopes of this Client.

        Restricts this client's access to specific scopes.  # noqa: E501

        :param restrict_scopes: The restrict_scopes of this Client.  # noqa: E501
        :type: bool
        """

        self._restrict_scopes = restrict_scopes

    @property
    def restricted_scopes(self):
        """Gets the restricted_scopes of this Client.  # noqa: E501

        The scopes available for this client.  # noqa: E501

        :return: The restricted_scopes of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._restricted_scopes

    @restricted_scopes.setter
    def restricted_scopes(self, restricted_scopes):
        """Sets the restricted_scopes of this Client.

        The scopes available for this client.  # noqa: E501

        :param restricted_scopes: The restricted_scopes of this Client.  # noqa: E501
        :type: list[str]
        """

        self._restricted_scopes = restricted_scopes

    @property
    def exclusive_scopes(self):
        """Gets the exclusive_scopes of this Client.  # noqa: E501

        The exclusive scopes available for this client.  # noqa: E501

        :return: The exclusive_scopes of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._exclusive_scopes

    @exclusive_scopes.setter
    def exclusive_scopes(self, exclusive_scopes):
        """Sets the exclusive_scopes of this Client.

        The exclusive scopes available for this client.  # noqa: E501

        :param exclusive_scopes: The exclusive_scopes of this Client.  # noqa: E501
        :type: list[str]
        """

        self._exclusive_scopes = exclusive_scopes

    @property
    def authorization_detail_types(self):
        """Gets the authorization_detail_types of this Client.  # noqa: E501

        The authorization detail types available for this client.  # noqa: E501

        :return: The authorization_detail_types of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._authorization_detail_types

    @authorization_detail_types.setter
    def authorization_detail_types(self, authorization_detail_types):
        """Sets the authorization_detail_types of this Client.

        The authorization detail types available for this client.  # noqa: E501

        :param authorization_detail_types: The authorization_detail_types of this Client.  # noqa: E501
        :type: list[str]
        """

        self._authorization_detail_types = authorization_detail_types

    @property
    def restricted_response_types(self):
        """Gets the restricted_response_types of this Client.  # noqa: E501

        The response types allowed for this client. If omitted all response types are available to the client.  # noqa: E501

        :return: The restricted_response_types of this Client.  # noqa: E501
        :rtype: list[str]
        """
        return self._restricted_response_types

    @restricted_response_types.setter
    def restricted_response_types(self, restricted_response_types):
        """Sets the restricted_response_types of this Client.

        The response types allowed for this client. If omitted all response types are available to the client.  # noqa: E501

        :param restricted_response_types: The restricted_response_types of this Client.  # noqa: E501
        :type: list[str]
        """

        self._restricted_response_types = restricted_response_types

    @property
    def require_pushed_authorization_requests(self):
        """Gets the require_pushed_authorization_requests of this Client.  # noqa: E501

        Determines whether pushed authorization requests are required when initiating an authorization request. The default is false.  # noqa: E501

        :return: The require_pushed_authorization_requests of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._require_pushed_authorization_requests

    @require_pushed_authorization_requests.setter
    def require_pushed_authorization_requests(self, require_pushed_authorization_requests):
        """Sets the require_pushed_authorization_requests of this Client.

        Determines whether pushed authorization requests are required when initiating an authorization request. The default is false.  # noqa: E501

        :param require_pushed_authorization_requests: The require_pushed_authorization_requests of this Client.  # noqa: E501
        :type: bool
        """

        self._require_pushed_authorization_requests = require_pushed_authorization_requests

    @property
    def require_jwt_secured_authorization_response_mode(self):
        """Gets the require_jwt_secured_authorization_response_mode of this Client.  # noqa: E501

        Determines whether JWT Secured authorization response mode is required when initiating an authorization request. The default is false.  # noqa: E501

        :return: The require_jwt_secured_authorization_response_mode of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._require_jwt_secured_authorization_response_mode

    @require_jwt_secured_authorization_response_mode.setter
    def require_jwt_secured_authorization_response_mode(self, require_jwt_secured_authorization_response_mode):
        """Sets the require_jwt_secured_authorization_response_mode of this Client.

        Determines whether JWT Secured authorization response mode is required when initiating an authorization request. The default is false.  # noqa: E501

        :param require_jwt_secured_authorization_response_mode: The require_jwt_secured_authorization_response_mode of this Client.  # noqa: E501
        :type: bool
        """

        self._require_jwt_secured_authorization_response_mode = require_jwt_secured_authorization_response_mode

    @property
    def require_signed_requests(self):
        """Gets the require_signed_requests of this Client.  # noqa: E501

        Determines whether signed requests are required for this client  # noqa: E501

        :return: The require_signed_requests of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._require_signed_requests

    @require_signed_requests.setter
    def require_signed_requests(self, require_signed_requests):
        """Sets the require_signed_requests of this Client.

        Determines whether signed requests are required for this client  # noqa: E501

        :param require_signed_requests: The require_signed_requests of this Client.  # noqa: E501
        :type: bool
        """

        self._require_signed_requests = require_signed_requests

    @property
    def request_object_signing_algorithm(self):
        """Gets the request_object_signing_algorithm of this Client.  # noqa: E501

        The JSON Web Signature [JWS] algorithm that must be used to sign the Request Object. All signing algorithms are allowed if value is not present <br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11.  # noqa: E501

        :return: The request_object_signing_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._request_object_signing_algorithm

    @request_object_signing_algorithm.setter
    def request_object_signing_algorithm(self, request_object_signing_algorithm):
        """Sets the request_object_signing_algorithm of this Client.

        The JSON Web Signature [JWS] algorithm that must be used to sign the Request Object. All signing algorithms are allowed if value is not present <br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11.  # noqa: E501

        :param request_object_signing_algorithm: The request_object_signing_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512"]  # noqa: E501
        if (self._configuration.client_side_validation and
                request_object_signing_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `request_object_signing_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(request_object_signing_algorithm, allowed_values)
            )

        self._request_object_signing_algorithm = request_object_signing_algorithm

    @property
    def oidc_policy(self):
        """Gets the oidc_policy of this Client.  # noqa: E501

        Open ID Connect Policy settings.  This is included in the message only when OIDC is enabled.  # noqa: E501

        :return: The oidc_policy of this Client.  # noqa: E501
        :rtype: ClientOIDCPolicy
        """
        return self._oidc_policy

    @oidc_policy.setter
    def oidc_policy(self, oidc_policy):
        """Sets the oidc_policy of this Client.

        Open ID Connect Policy settings.  This is included in the message only when OIDC is enabled.  # noqa: E501

        :param oidc_policy: The oidc_policy of this Client.  # noqa: E501
        :type: ClientOIDCPolicy
        """

        self._oidc_policy = oidc_policy

    @property
    def client_auth(self):
        """Gets the client_auth of this Client.  # noqa: E501

        Client authentication settings.  If this model is null, it indicates that no client authentication will be used.  # noqa: E501

        :return: The client_auth of this Client.  # noqa: E501
        :rtype: ClientAuth
        """
        return self._client_auth

    @client_auth.setter
    def client_auth(self, client_auth):
        """Sets the client_auth of this Client.

        Client authentication settings.  If this model is null, it indicates that no client authentication will be used.  # noqa: E501

        :param client_auth: The client_auth of this Client.  # noqa: E501
        :type: ClientAuth
        """

        self._client_auth = client_auth

    @property
    def jwks_settings(self):
        """Gets the jwks_settings of this Client.  # noqa: E501

        JSON Web Key Set Settings of the OAuth client. Required if private key JWT client authentication or signed requests is enabled.  # noqa: E501

        :return: The jwks_settings of this Client.  # noqa: E501
        :rtype: JwksSettings
        """
        return self._jwks_settings

    @jwks_settings.setter
    def jwks_settings(self, jwks_settings):
        """Sets the jwks_settings of this Client.

        JSON Web Key Set Settings of the OAuth client. Required if private key JWT client authentication or signed requests is enabled.  # noqa: E501

        :param jwks_settings: The jwks_settings of this Client.  # noqa: E501
        :type: JwksSettings
        """

        self._jwks_settings = jwks_settings

    @property
    def extended_parameters(self):
        """Gets the extended_parameters of this Client.  # noqa: E501

        OAuth Client Metadata can be extended to use custom Client Metadata Parameters. The names of these custom parameters should be defined in /extendedProperties.  # noqa: E501

        :return: The extended_parameters of this Client.  # noqa: E501
        :rtype: dict(str, ParameterValues)
        """
        return self._extended_parameters

    @extended_parameters.setter
    def extended_parameters(self, extended_parameters):
        """Sets the extended_parameters of this Client.

        OAuth Client Metadata can be extended to use custom Client Metadata Parameters. The names of these custom parameters should be defined in /extendedProperties.  # noqa: E501

        :param extended_parameters: The extended_parameters of this Client.  # noqa: E501
        :type: dict(str, ParameterValues)
        """

        self._extended_parameters = extended_parameters

    @property
    def device_flow_setting_type(self):
        """Gets the device_flow_setting_type of this Client.  # noqa: E501

        Allows an administrator to override the Device Authorization Settings set globally for the OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The device_flow_setting_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._device_flow_setting_type

    @device_flow_setting_type.setter
    def device_flow_setting_type(self, device_flow_setting_type):
        """Sets the device_flow_setting_type of this Client.

        Allows an administrator to override the Device Authorization Settings set globally for the OAuth AS. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param device_flow_setting_type: The device_flow_setting_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                device_flow_setting_type not in allowed_values):
            raise ValueError(
                "Invalid value for `device_flow_setting_type` ({0}), must be one of {1}"  # noqa: E501
                .format(device_flow_setting_type, allowed_values)
            )

        self._device_flow_setting_type = device_flow_setting_type

    @property
    def user_authorization_url_override(self):
        """Gets the user_authorization_url_override of this Client.  # noqa: E501

        The URL used as 'verification_url' and 'verification_url_complete' values in a Device Authorization request. This property overrides the 'userAuthorizationUrl' value present in Authorization Server Settings.  # noqa: E501

        :return: The user_authorization_url_override of this Client.  # noqa: E501
        :rtype: str
        """
        return self._user_authorization_url_override

    @user_authorization_url_override.setter
    def user_authorization_url_override(self, user_authorization_url_override):
        """Sets the user_authorization_url_override of this Client.

        The URL used as 'verification_url' and 'verification_url_complete' values in a Device Authorization request. This property overrides the 'userAuthorizationUrl' value present in Authorization Server Settings.  # noqa: E501

        :param user_authorization_url_override: The user_authorization_url_override of this Client.  # noqa: E501
        :type: str
        """

        self._user_authorization_url_override = user_authorization_url_override

    @property
    def pending_authorization_timeout_override(self):
        """Gets the pending_authorization_timeout_override of this Client.  # noqa: E501

        The 'device_code' and 'user_code' timeout, in seconds. This overrides the 'pendingAuthorizationTimeout' value present in Authorization Server Settings.  # noqa: E501

        :return: The pending_authorization_timeout_override of this Client.  # noqa: E501
        :rtype: int
        """
        return self._pending_authorization_timeout_override

    @pending_authorization_timeout_override.setter
    def pending_authorization_timeout_override(self, pending_authorization_timeout_override):
        """Sets the pending_authorization_timeout_override of this Client.

        The 'device_code' and 'user_code' timeout, in seconds. This overrides the 'pendingAuthorizationTimeout' value present in Authorization Server Settings.  # noqa: E501

        :param pending_authorization_timeout_override: The pending_authorization_timeout_override of this Client.  # noqa: E501
        :type: int
        """

        self._pending_authorization_timeout_override = pending_authorization_timeout_override

    @property
    def device_polling_interval_override(self):
        """Gets the device_polling_interval_override of this Client.  # noqa: E501

        The amount of time client should wait between polling requests, in seconds. This overrides the 'devicePollingInterval' value present in Authorization Server Settings.  # noqa: E501

        :return: The device_polling_interval_override of this Client.  # noqa: E501
        :rtype: int
        """
        return self._device_polling_interval_override

    @device_polling_interval_override.setter
    def device_polling_interval_override(self, device_polling_interval_override):
        """Sets the device_polling_interval_override of this Client.

        The amount of time client should wait between polling requests, in seconds. This overrides the 'devicePollingInterval' value present in Authorization Server Settings.  # noqa: E501

        :param device_polling_interval_override: The device_polling_interval_override of this Client.  # noqa: E501
        :type: int
        """

        self._device_polling_interval_override = device_polling_interval_override

    @property
    def bypass_activation_code_confirmation_override(self):
        """Gets the bypass_activation_code_confirmation_override of this Client.  # noqa: E501

        Indicates if the Activation Code Confirmation page should be bypassed if 'verification_url_complete' is used by the end user to authorize a device. This overrides the 'bypassUseCodeConfirmation' value present in Authorization Server Settings.  # noqa: E501

        :return: The bypass_activation_code_confirmation_override of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._bypass_activation_code_confirmation_override

    @bypass_activation_code_confirmation_override.setter
    def bypass_activation_code_confirmation_override(self, bypass_activation_code_confirmation_override):
        """Sets the bypass_activation_code_confirmation_override of this Client.

        Indicates if the Activation Code Confirmation page should be bypassed if 'verification_url_complete' is used by the end user to authorize a device. This overrides the 'bypassUseCodeConfirmation' value present in Authorization Server Settings.  # noqa: E501

        :param bypass_activation_code_confirmation_override: The bypass_activation_code_confirmation_override of this Client.  # noqa: E501
        :type: bool
        """

        self._bypass_activation_code_confirmation_override = bypass_activation_code_confirmation_override

    @property
    def require_proof_key_for_code_exchange(self):
        """Gets the require_proof_key_for_code_exchange of this Client.  # noqa: E501

        Determines whether Proof Key for Code Exchange (PKCE) is required for this client.  # noqa: E501

        :return: The require_proof_key_for_code_exchange of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._require_proof_key_for_code_exchange

    @require_proof_key_for_code_exchange.setter
    def require_proof_key_for_code_exchange(self, require_proof_key_for_code_exchange):
        """Sets the require_proof_key_for_code_exchange of this Client.

        Determines whether Proof Key for Code Exchange (PKCE) is required for this client.  # noqa: E501

        :param require_proof_key_for_code_exchange: The require_proof_key_for_code_exchange of this Client.  # noqa: E501
        :type: bool
        """

        self._require_proof_key_for_code_exchange = require_proof_key_for_code_exchange

    @property
    def ciba_delivery_mode(self):
        """Gets the ciba_delivery_mode of this Client.  # noqa: E501

        The token delivery mode for the client.  The default value is 'POLL'.  # noqa: E501

        :return: The ciba_delivery_mode of this Client.  # noqa: E501
        :rtype: str
        """
        return self._ciba_delivery_mode

    @ciba_delivery_mode.setter
    def ciba_delivery_mode(self, ciba_delivery_mode):
        """Sets the ciba_delivery_mode of this Client.

        The token delivery mode for the client.  The default value is 'POLL'.  # noqa: E501

        :param ciba_delivery_mode: The ciba_delivery_mode of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["POLL", "PING"]  # noqa: E501
        if (self._configuration.client_side_validation and
                ciba_delivery_mode not in allowed_values):
            raise ValueError(
                "Invalid value for `ciba_delivery_mode` ({0}), must be one of {1}"  # noqa: E501
                .format(ciba_delivery_mode, allowed_values)
            )

        self._ciba_delivery_mode = ciba_delivery_mode

    @property
    def ciba_notification_endpoint(self):
        """Gets the ciba_notification_endpoint of this Client.  # noqa: E501

        The endpoint the OP will call after a successful or failed end-user authentication.  # noqa: E501

        :return: The ciba_notification_endpoint of this Client.  # noqa: E501
        :rtype: str
        """
        return self._ciba_notification_endpoint

    @ciba_notification_endpoint.setter
    def ciba_notification_endpoint(self, ciba_notification_endpoint):
        """Sets the ciba_notification_endpoint of this Client.

        The endpoint the OP will call after a successful or failed end-user authentication.  # noqa: E501

        :param ciba_notification_endpoint: The ciba_notification_endpoint of this Client.  # noqa: E501
        :type: str
        """

        self._ciba_notification_endpoint = ciba_notification_endpoint

    @property
    def ciba_polling_interval(self):
        """Gets the ciba_polling_interval of this Client.  # noqa: E501

        The minimum amount of time in seconds that the Client must wait between polling requests to the token endpoint. The default is 3 seconds.  # noqa: E501

        :return: The ciba_polling_interval of this Client.  # noqa: E501
        :rtype: int
        """
        return self._ciba_polling_interval

    @ciba_polling_interval.setter
    def ciba_polling_interval(self, ciba_polling_interval):
        """Sets the ciba_polling_interval of this Client.

        The minimum amount of time in seconds that the Client must wait between polling requests to the token endpoint. The default is 3 seconds.  # noqa: E501

        :param ciba_polling_interval: The ciba_polling_interval of this Client.  # noqa: E501
        :type: int
        """

        self._ciba_polling_interval = ciba_polling_interval

    @property
    def ciba_require_signed_requests(self):
        """Gets the ciba_require_signed_requests of this Client.  # noqa: E501

        Determines whether CIBA signed requests are required for this client.  # noqa: E501

        :return: The ciba_require_signed_requests of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._ciba_require_signed_requests

    @ciba_require_signed_requests.setter
    def ciba_require_signed_requests(self, ciba_require_signed_requests):
        """Sets the ciba_require_signed_requests of this Client.

        Determines whether CIBA signed requests are required for this client.  # noqa: E501

        :param ciba_require_signed_requests: The ciba_require_signed_requests of this Client.  # noqa: E501
        :type: bool
        """

        self._ciba_require_signed_requests = ciba_require_signed_requests

    @property
    def ciba_request_object_signing_algorithm(self):
        """Gets the ciba_request_object_signing_algorithm of this Client.  # noqa: E501

        The JSON Web Signature [JWS] algorithm that must be used to sign the CIBA Request Object. All signing algorithms are allowed if value is not present <br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11.  # noqa: E501

        :return: The ciba_request_object_signing_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._ciba_request_object_signing_algorithm

    @ciba_request_object_signing_algorithm.setter
    def ciba_request_object_signing_algorithm(self, ciba_request_object_signing_algorithm):
        """Sets the ciba_request_object_signing_algorithm of this Client.

        The JSON Web Signature [JWS] algorithm that must be used to sign the CIBA Request Object. All signing algorithms are allowed if value is not present <br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11.  # noqa: E501

        :param ciba_request_object_signing_algorithm: The ciba_request_object_signing_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512"]  # noqa: E501
        if (self._configuration.client_side_validation and
                ciba_request_object_signing_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `ciba_request_object_signing_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(ciba_request_object_signing_algorithm, allowed_values)
            )

        self._ciba_request_object_signing_algorithm = ciba_request_object_signing_algorithm

    @property
    def ciba_user_code_supported(self):
        """Gets the ciba_user_code_supported of this Client.  # noqa: E501

        Determines whether CIBA user code is supported for this client.  # noqa: E501

        :return: The ciba_user_code_supported of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._ciba_user_code_supported

    @ciba_user_code_supported.setter
    def ciba_user_code_supported(self, ciba_user_code_supported):
        """Sets the ciba_user_code_supported of this Client.

        Determines whether CIBA user code is supported for this client.  # noqa: E501

        :param ciba_user_code_supported: The ciba_user_code_supported of this Client.  # noqa: E501
        :type: bool
        """

        self._ciba_user_code_supported = ciba_user_code_supported

    @property
    def request_policy_ref(self):
        """Gets the request_policy_ref of this Client.  # noqa: E501

        The CIBA request policy.  # noqa: E501

        :return: The request_policy_ref of this Client.  # noqa: E501
        :rtype: ResourceLink
        """
        return self._request_policy_ref

    @request_policy_ref.setter
    def request_policy_ref(self, request_policy_ref):
        """Sets the request_policy_ref of this Client.

        The CIBA request policy.  # noqa: E501

        :param request_policy_ref: The request_policy_ref of this Client.  # noqa: E501
        :type: ResourceLink
        """

        self._request_policy_ref = request_policy_ref

    @property
    def token_exchange_processor_policy_ref(self):
        """Gets the token_exchange_processor_policy_ref of this Client.  # noqa: E501

        The Token Exchange Processor policy.  # noqa: E501

        :return: The token_exchange_processor_policy_ref of this Client.  # noqa: E501
        :rtype: ResourceLink
        """
        return self._token_exchange_processor_policy_ref

    @token_exchange_processor_policy_ref.setter
    def token_exchange_processor_policy_ref(self, token_exchange_processor_policy_ref):
        """Sets the token_exchange_processor_policy_ref of this Client.

        The Token Exchange Processor policy.  # noqa: E501

        :param token_exchange_processor_policy_ref: The token_exchange_processor_policy_ref of this Client.  # noqa: E501
        :type: ResourceLink
        """

        self._token_exchange_processor_policy_ref = token_exchange_processor_policy_ref

    @property
    def refresh_token_rolling_grace_period_type(self):
        """Gets the refresh_token_rolling_grace_period_type of this Client.  # noqa: E501

        When specified, it overrides the global Refresh Token Grace Period defined in the Authorization Server Settings. The default value is SERVER_DEFAULT  # noqa: E501

        :return: The refresh_token_rolling_grace_period_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._refresh_token_rolling_grace_period_type

    @refresh_token_rolling_grace_period_type.setter
    def refresh_token_rolling_grace_period_type(self, refresh_token_rolling_grace_period_type):
        """Sets the refresh_token_rolling_grace_period_type of this Client.

        When specified, it overrides the global Refresh Token Grace Period defined in the Authorization Server Settings. The default value is SERVER_DEFAULT  # noqa: E501

        :param refresh_token_rolling_grace_period_type: The refresh_token_rolling_grace_period_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                refresh_token_rolling_grace_period_type not in allowed_values):
            raise ValueError(
                "Invalid value for `refresh_token_rolling_grace_period_type` ({0}), must be one of {1}"  # noqa: E501
                .format(refresh_token_rolling_grace_period_type, allowed_values)
            )

        self._refresh_token_rolling_grace_period_type = refresh_token_rolling_grace_period_type

    @property
    def refresh_token_rolling_grace_period(self):
        """Gets the refresh_token_rolling_grace_period of this Client.  # noqa: E501

        The grace period that a rolled refresh token remains valid in seconds.  # noqa: E501

        :return: The refresh_token_rolling_grace_period of this Client.  # noqa: E501
        :rtype: int
        """
        return self._refresh_token_rolling_grace_period

    @refresh_token_rolling_grace_period.setter
    def refresh_token_rolling_grace_period(self, refresh_token_rolling_grace_period):
        """Sets the refresh_token_rolling_grace_period of this Client.

        The grace period that a rolled refresh token remains valid in seconds.  # noqa: E501

        :param refresh_token_rolling_grace_period: The refresh_token_rolling_grace_period of this Client.  # noqa: E501
        :type: int
        """

        self._refresh_token_rolling_grace_period = refresh_token_rolling_grace_period

    @property
    def client_secret_retention_period_type(self):
        """Gets the client_secret_retention_period_type of this Client.  # noqa: E501

        Use OVERRIDE_SERVER_DEFAULT to override the Client Secret Retention Period value on the Authorization Server Settings. SERVER_DEFAULT will default to the Client Secret Retention Period value on the Authorization Server Setting. Defaults to SERVER_DEFAULT.  # noqa: E501

        :return: The client_secret_retention_period_type of this Client.  # noqa: E501
        :rtype: str
        """
        return self._client_secret_retention_period_type

    @client_secret_retention_period_type.setter
    def client_secret_retention_period_type(self, client_secret_retention_period_type):
        """Sets the client_secret_retention_period_type of this Client.

        Use OVERRIDE_SERVER_DEFAULT to override the Client Secret Retention Period value on the Authorization Server Settings. SERVER_DEFAULT will default to the Client Secret Retention Period value on the Authorization Server Setting. Defaults to SERVER_DEFAULT.  # noqa: E501

        :param client_secret_retention_period_type: The client_secret_retention_period_type of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["SERVER_DEFAULT", "OVERRIDE_SERVER_DEFAULT"]  # noqa: E501
        if (self._configuration.client_side_validation and
                client_secret_retention_period_type not in allowed_values):
            raise ValueError(
                "Invalid value for `client_secret_retention_period_type` ({0}), must be one of {1}"  # noqa: E501
                .format(client_secret_retention_period_type, allowed_values)
            )

        self._client_secret_retention_period_type = client_secret_retention_period_type

    @property
    def client_secret_retention_period(self):
        """Gets the client_secret_retention_period of this Client.  # noqa: E501

        The length of time in minutes that client secrets will be retained as secondary secrets after secret change. The default value is 0, which will disable secondary client secret retention. This value will override the Client Secret Retention Period value on the Authorization Server Settings.  # noqa: E501

        :return: The client_secret_retention_period of this Client.  # noqa: E501
        :rtype: int
        """
        return self._client_secret_retention_period

    @client_secret_retention_period.setter
    def client_secret_retention_period(self, client_secret_retention_period):
        """Sets the client_secret_retention_period of this Client.

        The length of time in minutes that client secrets will be retained as secondary secrets after secret change. The default value is 0, which will disable secondary client secret retention. This value will override the Client Secret Retention Period value on the Authorization Server Settings.  # noqa: E501

        :param client_secret_retention_period: The client_secret_retention_period of this Client.  # noqa: E501
        :type: int
        """

        self._client_secret_retention_period = client_secret_retention_period

    @property
    def client_secret_changed_time(self):
        """Gets the client_secret_changed_time of this Client.  # noqa: E501

        The time at which the client secret was last changed. This property is read only and is ignored on PUT and POST requests.  # noqa: E501

        :return: The client_secret_changed_time of this Client.  # noqa: E501
        :rtype: datetime
        """
        return self._client_secret_changed_time

    @client_secret_changed_time.setter
    def client_secret_changed_time(self, client_secret_changed_time):
        """Sets the client_secret_changed_time of this Client.

        The time at which the client secret was last changed. This property is read only and is ignored on PUT and POST requests.  # noqa: E501

        :param client_secret_changed_time: The client_secret_changed_time of this Client.  # noqa: E501
        :type: datetime
        """

        self._client_secret_changed_time = client_secret_changed_time

    @property
    def token_introspection_signing_algorithm(self):
        """Gets the token_introspection_signing_algorithm of this Client.  # noqa: E501

        The JSON Web Signature [JWS] algorithm required to sign the Token Introspection Response.<br>HS256 - HMAC using SHA-256<br>HS384 - HMAC using SHA-384<br>HS512 - HMAC using SHA-512<br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>A null value will represent the default algorithm which is RS256.<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11  # noqa: E501

        :return: The token_introspection_signing_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._token_introspection_signing_algorithm

    @token_introspection_signing_algorithm.setter
    def token_introspection_signing_algorithm(self, token_introspection_signing_algorithm):
        """Sets the token_introspection_signing_algorithm of this Client.

        The JSON Web Signature [JWS] algorithm required to sign the Token Introspection Response.<br>HS256 - HMAC using SHA-256<br>HS384 - HMAC using SHA-384<br>HS512 - HMAC using SHA-512<br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>A null value will represent the default algorithm which is RS256.<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11  # noqa: E501

        :param token_introspection_signing_algorithm: The token_introspection_signing_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["RS256", "RS384", "RS512", "HS256", "HS384", "HS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512"]  # noqa: E501
        if (self._configuration.client_side_validation and
                token_introspection_signing_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `token_introspection_signing_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(token_introspection_signing_algorithm, allowed_values)
            )

        self._token_introspection_signing_algorithm = token_introspection_signing_algorithm

    @property
    def token_introspection_encryption_algorithm(self):
        """Gets the token_introspection_encryption_algorithm of this Client.  # noqa: E501

        The JSON Web Encryption [JWE] encryption algorithm used to encrypt the content-encryption key of the Token Introspection Response.<br>DIR - Direct Encryption with symmetric key<br>A128KW - AES-128 Key Wrap<br>A192KW - AES-192 Key Wrap<br>A256KW - AES-256 Key Wrap<br>A128GCMKW - AES-GCM-128 key encryption<br>A192GCMKW - AES-GCM-192 key encryption<br>A256GCMKW - AES-GCM-256 key encryption<br>ECDH_ES - ECDH-ES<br>ECDH_ES_A128KW - ECDH-ES with AES-128 Key Wrap<br>ECDH_ES_A192KW - ECDH-ES with AES-192 Key Wrap<br>ECDH_ES_A256KW - ECDH-ES with AES-256 Key Wrap<br>RSA_OAEP - RSAES OAEP<br>RSA_OAEP_256 - RSAES OAEP using SHA-256 and MGF1 with SHA-256  # noqa: E501

        :return: The token_introspection_encryption_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._token_introspection_encryption_algorithm

    @token_introspection_encryption_algorithm.setter
    def token_introspection_encryption_algorithm(self, token_introspection_encryption_algorithm):
        """Sets the token_introspection_encryption_algorithm of this Client.

        The JSON Web Encryption [JWE] encryption algorithm used to encrypt the content-encryption key of the Token Introspection Response.<br>DIR - Direct Encryption with symmetric key<br>A128KW - AES-128 Key Wrap<br>A192KW - AES-192 Key Wrap<br>A256KW - AES-256 Key Wrap<br>A128GCMKW - AES-GCM-128 key encryption<br>A192GCMKW - AES-GCM-192 key encryption<br>A256GCMKW - AES-GCM-256 key encryption<br>ECDH_ES - ECDH-ES<br>ECDH_ES_A128KW - ECDH-ES with AES-128 Key Wrap<br>ECDH_ES_A192KW - ECDH-ES with AES-192 Key Wrap<br>ECDH_ES_A256KW - ECDH-ES with AES-256 Key Wrap<br>RSA_OAEP - RSAES OAEP<br>RSA_OAEP_256 - RSAES OAEP using SHA-256 and MGF1 with SHA-256  # noqa: E501

        :param token_introspection_encryption_algorithm: The token_introspection_encryption_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["DIR", "A128KW", "A192KW", "A256KW", "A128GCMKW", "A192GCMKW", "A256GCMKW", "ECDH_ES", "ECDH_ES_A128KW", "ECDH_ES_A192KW", "ECDH_ES_A256KW", "RSA_OAEP", "RSA_OAEP_256"]  # noqa: E501
        if (self._configuration.client_side_validation and
                token_introspection_encryption_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `token_introspection_encryption_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(token_introspection_encryption_algorithm, allowed_values)
            )

        self._token_introspection_encryption_algorithm = token_introspection_encryption_algorithm

    @property
    def token_introspection_content_encryption_algorithm(self):
        """Gets the token_introspection_content_encryption_algorithm of this Client.  # noqa: E501

        The JSON Web Encryption [JWE] content-encryption algorithm for the Token Introspection Response.<br>AES_128_CBC_HMAC_SHA_256 - Composite AES-CBC-128 HMAC-SHA-256<br>AES_192_CBC_HMAC_SHA_384 - Composite AES-CBC-192 HMAC-SHA-384<br>AES_256_CBC_HMAC_SHA_512 - Composite AES-CBC-256 HMAC-SHA-512<br>AES_128_GCM - AES-GCM-128<br>AES_192_GCM - AES-GCM-192<br>AES_256_GCM - AES-GCM-256  # noqa: E501

        :return: The token_introspection_content_encryption_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._token_introspection_content_encryption_algorithm

    @token_introspection_content_encryption_algorithm.setter
    def token_introspection_content_encryption_algorithm(self, token_introspection_content_encryption_algorithm):
        """Sets the token_introspection_content_encryption_algorithm of this Client.

        The JSON Web Encryption [JWE] content-encryption algorithm for the Token Introspection Response.<br>AES_128_CBC_HMAC_SHA_256 - Composite AES-CBC-128 HMAC-SHA-256<br>AES_192_CBC_HMAC_SHA_384 - Composite AES-CBC-192 HMAC-SHA-384<br>AES_256_CBC_HMAC_SHA_512 - Composite AES-CBC-256 HMAC-SHA-512<br>AES_128_GCM - AES-GCM-128<br>AES_192_GCM - AES-GCM-192<br>AES_256_GCM - AES-GCM-256  # noqa: E501

        :param token_introspection_content_encryption_algorithm: The token_introspection_content_encryption_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["AES_128_CBC_HMAC_SHA_256", "AES_192_CBC_HMAC_SHA_384", "AES_256_CBC_HMAC_SHA_512", "AES_128_GCM", "AES_192_GCM", "AES_256_GCM"]  # noqa: E501
        if (self._configuration.client_side_validation and
                token_introspection_content_encryption_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `token_introspection_content_encryption_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(token_introspection_content_encryption_algorithm, allowed_values)
            )

        self._token_introspection_content_encryption_algorithm = token_introspection_content_encryption_algorithm

    @property
    def jwt_secured_authorization_response_mode_signing_algorithm(self):
        """Gets the jwt_secured_authorization_response_mode_signing_algorithm of this Client.  # noqa: E501

        The JSON Web Signature [JWS] algorithm required to sign the JWT Secured Authorization Response.<br>HS256 - HMAC using SHA-256<br>HS384 - HMAC using SHA-384<br>HS512 - HMAC using SHA-512<br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>A null value will represent the default algorithm which is RS256.<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11  # noqa: E501

        :return: The jwt_secured_authorization_response_mode_signing_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._jwt_secured_authorization_response_mode_signing_algorithm

    @jwt_secured_authorization_response_mode_signing_algorithm.setter
    def jwt_secured_authorization_response_mode_signing_algorithm(self, jwt_secured_authorization_response_mode_signing_algorithm):
        """Sets the jwt_secured_authorization_response_mode_signing_algorithm of this Client.

        The JSON Web Signature [JWS] algorithm required to sign the JWT Secured Authorization Response.<br>HS256 - HMAC using SHA-256<br>HS384 - HMAC using SHA-384<br>HS512 - HMAC using SHA-512<br>RS256 - RSA using SHA-256<br>RS384 - RSA using SHA-384<br>RS512 - RSA using SHA-512<br>ES256 - ECDSA using P256 Curve and SHA-256<br>ES384 - ECDSA using P384 Curve and SHA-384<br>ES512 - ECDSA using P521 Curve and SHA-512<br>PS256 - RSASSA-PSS using SHA-256 and MGF1 padding with SHA-256<br>PS384 - RSASSA-PSS using SHA-384 and MGF1 padding with SHA-384<br>PS512 - RSASSA-PSS using SHA-512 and MGF1 padding with SHA-512<br>A null value will represent the default algorithm which is RS256.<br>RSASSA-PSS is only supported with SafeNet Luna, Thales nCipher or Java 11  # noqa: E501

        :param jwt_secured_authorization_response_mode_signing_algorithm: The jwt_secured_authorization_response_mode_signing_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["RS256", "RS384", "RS512", "HS256", "HS384", "HS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512"]  # noqa: E501
        if (self._configuration.client_side_validation and
                jwt_secured_authorization_response_mode_signing_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `jwt_secured_authorization_response_mode_signing_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(jwt_secured_authorization_response_mode_signing_algorithm, allowed_values)
            )

        self._jwt_secured_authorization_response_mode_signing_algorithm = jwt_secured_authorization_response_mode_signing_algorithm

    @property
    def jwt_secured_authorization_response_mode_encryption_algorithm(self):
        """Gets the jwt_secured_authorization_response_mode_encryption_algorithm of this Client.  # noqa: E501

        The JSON Web Encryption [JWE] encryption algorithm used to encrypt the content-encryption key of the JWT Secured Authorization Response.<br>DIR - Direct Encryption with symmetric key<br>A128KW - AES-128 Key Wrap<br>A192KW - AES-192 Key Wrap<br>A256KW - AES-256 Key Wrap<br>A128GCMKW - AES-GCM-128 key encryption<br>A192GCMKW - AES-GCM-192 key encryption<br>A256GCMKW - AES-GCM-256 key encryption<br>ECDH_ES - ECDH-ES<br>ECDH_ES_A128KW - ECDH-ES with AES-128 Key Wrap<br>ECDH_ES_A192KW - ECDH-ES with AES-192 Key Wrap<br>ECDH_ES_A256KW - ECDH-ES with AES-256 Key Wrap<br>RSA_OAEP - RSAES OAEP<br>RSA_OAEP_256 - RSAES OAEP using SHA-256 and MGF1 with SHA-256  # noqa: E501

        :return: The jwt_secured_authorization_response_mode_encryption_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._jwt_secured_authorization_response_mode_encryption_algorithm

    @jwt_secured_authorization_response_mode_encryption_algorithm.setter
    def jwt_secured_authorization_response_mode_encryption_algorithm(self, jwt_secured_authorization_response_mode_encryption_algorithm):
        """Sets the jwt_secured_authorization_response_mode_encryption_algorithm of this Client.

        The JSON Web Encryption [JWE] encryption algorithm used to encrypt the content-encryption key of the JWT Secured Authorization Response.<br>DIR - Direct Encryption with symmetric key<br>A128KW - AES-128 Key Wrap<br>A192KW - AES-192 Key Wrap<br>A256KW - AES-256 Key Wrap<br>A128GCMKW - AES-GCM-128 key encryption<br>A192GCMKW - AES-GCM-192 key encryption<br>A256GCMKW - AES-GCM-256 key encryption<br>ECDH_ES - ECDH-ES<br>ECDH_ES_A128KW - ECDH-ES with AES-128 Key Wrap<br>ECDH_ES_A192KW - ECDH-ES with AES-192 Key Wrap<br>ECDH_ES_A256KW - ECDH-ES with AES-256 Key Wrap<br>RSA_OAEP - RSAES OAEP<br>RSA_OAEP_256 - RSAES OAEP using SHA-256 and MGF1 with SHA-256  # noqa: E501

        :param jwt_secured_authorization_response_mode_encryption_algorithm: The jwt_secured_authorization_response_mode_encryption_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["DIR", "A128KW", "A192KW", "A256KW", "A128GCMKW", "A192GCMKW", "A256GCMKW", "ECDH_ES", "ECDH_ES_A128KW", "ECDH_ES_A192KW", "ECDH_ES_A256KW", "RSA_OAEP", "RSA_OAEP_256"]  # noqa: E501
        if (self._configuration.client_side_validation and
                jwt_secured_authorization_response_mode_encryption_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `jwt_secured_authorization_response_mode_encryption_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(jwt_secured_authorization_response_mode_encryption_algorithm, allowed_values)
            )

        self._jwt_secured_authorization_response_mode_encryption_algorithm = jwt_secured_authorization_response_mode_encryption_algorithm

    @property
    def jwt_secured_authorization_response_mode_content_encryption_algorithm(self):
        """Gets the jwt_secured_authorization_response_mode_content_encryption_algorithm of this Client.  # noqa: E501

        The JSON Web Encryption [JWE] content-encryption algorithm for the JWT Secured Authorization Response.<br>AES_128_CBC_HMAC_SHA_256 - Composite AES-CBC-128 HMAC-SHA-256<br>AES_192_CBC_HMAC_SHA_384 - Composite AES-CBC-192 HMAC-SHA-384<br>AES_256_CBC_HMAC_SHA_512 - Composite AES-CBC-256 HMAC-SHA-512<br>AES_128_GCM - AES-GCM-128<br>AES_192_GCM - AES-GCM-192<br>AES_256_GCM - AES-GCM-256  # noqa: E501

        :return: The jwt_secured_authorization_response_mode_content_encryption_algorithm of this Client.  # noqa: E501
        :rtype: str
        """
        return self._jwt_secured_authorization_response_mode_content_encryption_algorithm

    @jwt_secured_authorization_response_mode_content_encryption_algorithm.setter
    def jwt_secured_authorization_response_mode_content_encryption_algorithm(self, jwt_secured_authorization_response_mode_content_encryption_algorithm):
        """Sets the jwt_secured_authorization_response_mode_content_encryption_algorithm of this Client.

        The JSON Web Encryption [JWE] content-encryption algorithm for the JWT Secured Authorization Response.<br>AES_128_CBC_HMAC_SHA_256 - Composite AES-CBC-128 HMAC-SHA-256<br>AES_192_CBC_HMAC_SHA_384 - Composite AES-CBC-192 HMAC-SHA-384<br>AES_256_CBC_HMAC_SHA_512 - Composite AES-CBC-256 HMAC-SHA-512<br>AES_128_GCM - AES-GCM-128<br>AES_192_GCM - AES-GCM-192<br>AES_256_GCM - AES-GCM-256  # noqa: E501

        :param jwt_secured_authorization_response_mode_content_encryption_algorithm: The jwt_secured_authorization_response_mode_content_encryption_algorithm of this Client.  # noqa: E501
        :type: str
        """
        allowed_values = ["AES_128_CBC_HMAC_SHA_256", "AES_192_CBC_HMAC_SHA_384", "AES_256_CBC_HMAC_SHA_512", "AES_128_GCM", "AES_192_GCM", "AES_256_GCM"]  # noqa: E501
        if (self._configuration.client_side_validation and
                jwt_secured_authorization_response_mode_content_encryption_algorithm not in allowed_values):
            raise ValueError(
                "Invalid value for `jwt_secured_authorization_response_mode_content_encryption_algorithm` ({0}), must be one of {1}"  # noqa: E501
                .format(jwt_secured_authorization_response_mode_content_encryption_algorithm, allowed_values)
            )

        self._jwt_secured_authorization_response_mode_content_encryption_algorithm = jwt_secured_authorization_response_mode_content_encryption_algorithm

    @property
    def require_dpop(self):
        """Gets the require_dpop of this Client.  # noqa: E501

        Determines whether Demonstrating Proof-of-Possession (DPoP) is required for this client.  # noqa: E501

        :return: The require_dpop of this Client.  # noqa: E501
        :rtype: bool
        """
        return self._require_dpop

    @require_dpop.setter
    def require_dpop(self, require_dpop):
        """Sets the require_dpop of this Client.

        Determines whether Demonstrating Proof-of-Possession (DPoP) is required for this client.  # noqa: E501

        :param require_dpop: The require_dpop of this Client.  # noqa: E501
        :type: bool
        """

        self._require_dpop = require_dpop

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Client, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Client):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Client):
            return True

        return self.to_dict() != other.to_dict()
