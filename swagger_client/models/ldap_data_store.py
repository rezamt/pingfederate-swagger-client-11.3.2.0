# coding: utf-8

"""
    Administrative API Documentation

    The PingFederate Administrative API is a REST-based interface that provides a programmatic way to make configuration changes to PingFederate as an alternative to using the administrative console.<br/><br/>Expand the resources below to display implementation details on that resource such as the available endpoints, the parameter and response models for the operation, and the model structure of the resources themselves. Each resource operation comes with the ability to interact with the API. You are prompted for proper administration credentials when you try to perform an API operation.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from swagger_client.configuration import Configuration


class LdapDataStore(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'hostnames_tags': 'list[LdapTagConfig]',
        'hostnames': 'list[str]',
        'name': 'str',
        'ldap_type': 'str',
        'bind_anonymously': 'bool',
        'user_dn': 'str',
        'password': 'str',
        'encrypted_password': 'str',
        'client_tls_certificate_ref': 'ResourceLink',
        'use_ssl': 'bool',
        'use_dns_srv_records': 'bool',
        'follow_ldap_referrals': 'bool',
        'retry_failed_operations': 'bool',
        'test_on_borrow': 'bool',
        'test_on_return': 'bool',
        'create_if_necessary': 'bool',
        'verify_host': 'bool',
        'min_connections': 'int',
        'max_connections': 'int',
        'max_wait': 'int',
        'time_between_evictions': 'int',
        'read_timeout': 'int',
        'connection_timeout': 'int',
        'dns_ttl': 'int',
        'ldap_dns_srv_prefix': 'str',
        'ldaps_dns_srv_prefix': 'str',
        'binary_attributes': 'list[str]'
    }

    attribute_map = {
        'hostnames_tags': 'hostnamesTags',
        'hostnames': 'hostnames',
        'name': 'name',
        'ldap_type': 'ldapType',
        'bind_anonymously': 'bindAnonymously',
        'user_dn': 'userDN',
        'password': 'password',
        'encrypted_password': 'encryptedPassword',
        'client_tls_certificate_ref': 'clientTlsCertificateRef',
        'use_ssl': 'useSsl',
        'use_dns_srv_records': 'useDnsSrvRecords',
        'follow_ldap_referrals': 'followLDAPReferrals',
        'retry_failed_operations': 'retryFailedOperations',
        'test_on_borrow': 'testOnBorrow',
        'test_on_return': 'testOnReturn',
        'create_if_necessary': 'createIfNecessary',
        'verify_host': 'verifyHost',
        'min_connections': 'minConnections',
        'max_connections': 'maxConnections',
        'max_wait': 'maxWait',
        'time_between_evictions': 'timeBetweenEvictions',
        'read_timeout': 'readTimeout',
        'connection_timeout': 'connectionTimeout',
        'dns_ttl': 'dnsTtl',
        'ldap_dns_srv_prefix': 'ldapDnsSrvPrefix',
        'ldaps_dns_srv_prefix': 'ldapsDnsSrvPrefix',
        'binary_attributes': 'binaryAttributes'
    }

    def __init__(self, hostnames_tags=None, hostnames=None, name=None, ldap_type=None, bind_anonymously=None, user_dn=None, password=None, encrypted_password=None, client_tls_certificate_ref=None, use_ssl=None, use_dns_srv_records=None, follow_ldap_referrals=None, retry_failed_operations=None, test_on_borrow=None, test_on_return=None, create_if_necessary=None, verify_host=None, min_connections=None, max_connections=None, max_wait=None, time_between_evictions=None, read_timeout=None, connection_timeout=None, dns_ttl=None, ldap_dns_srv_prefix=None, ldaps_dns_srv_prefix=None, binary_attributes=None, _configuration=None):  # noqa: E501
        """LdapDataStore - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._hostnames_tags = None
        self._hostnames = None
        self._name = None
        self._ldap_type = None
        self._bind_anonymously = None
        self._user_dn = None
        self._password = None
        self._encrypted_password = None
        self._client_tls_certificate_ref = None
        self._use_ssl = None
        self._use_dns_srv_records = None
        self._follow_ldap_referrals = None
        self._retry_failed_operations = None
        self._test_on_borrow = None
        self._test_on_return = None
        self._create_if_necessary = None
        self._verify_host = None
        self._min_connections = None
        self._max_connections = None
        self._max_wait = None
        self._time_between_evictions = None
        self._read_timeout = None
        self._connection_timeout = None
        self._dns_ttl = None
        self._ldap_dns_srv_prefix = None
        self._ldaps_dns_srv_prefix = None
        self._binary_attributes = None
        self.discriminator = None

        if hostnames_tags is not None:
            self.hostnames_tags = hostnames_tags
        if hostnames is not None:
            self.hostnames = hostnames
        if name is not None:
            self.name = name
        self.ldap_type = ldap_type
        if bind_anonymously is not None:
            self.bind_anonymously = bind_anonymously
        if user_dn is not None:
            self.user_dn = user_dn
        if password is not None:
            self.password = password
        if encrypted_password is not None:
            self.encrypted_password = encrypted_password
        if client_tls_certificate_ref is not None:
            self.client_tls_certificate_ref = client_tls_certificate_ref
        if use_ssl is not None:
            self.use_ssl = use_ssl
        if use_dns_srv_records is not None:
            self.use_dns_srv_records = use_dns_srv_records
        if follow_ldap_referrals is not None:
            self.follow_ldap_referrals = follow_ldap_referrals
        if retry_failed_operations is not None:
            self.retry_failed_operations = retry_failed_operations
        if test_on_borrow is not None:
            self.test_on_borrow = test_on_borrow
        if test_on_return is not None:
            self.test_on_return = test_on_return
        if create_if_necessary is not None:
            self.create_if_necessary = create_if_necessary
        if verify_host is not None:
            self.verify_host = verify_host
        if min_connections is not None:
            self.min_connections = min_connections
        if max_connections is not None:
            self.max_connections = max_connections
        if max_wait is not None:
            self.max_wait = max_wait
        if time_between_evictions is not None:
            self.time_between_evictions = time_between_evictions
        if read_timeout is not None:
            self.read_timeout = read_timeout
        if connection_timeout is not None:
            self.connection_timeout = connection_timeout
        if dns_ttl is not None:
            self.dns_ttl = dns_ttl
        if ldap_dns_srv_prefix is not None:
            self.ldap_dns_srv_prefix = ldap_dns_srv_prefix
        if ldaps_dns_srv_prefix is not None:
            self.ldaps_dns_srv_prefix = ldaps_dns_srv_prefix
        if binary_attributes is not None:
            self.binary_attributes = binary_attributes

    @property
    def hostnames_tags(self):
        """Gets the hostnames_tags of this LdapDataStore.  # noqa: E501

        The set of host names and associated tags for this LDAP data store. This is required if 'hostnames' is not provided.  # noqa: E501

        :return: The hostnames_tags of this LdapDataStore.  # noqa: E501
        :rtype: list[LdapTagConfig]
        """
        return self._hostnames_tags

    @hostnames_tags.setter
    def hostnames_tags(self, hostnames_tags):
        """Sets the hostnames_tags of this LdapDataStore.

        The set of host names and associated tags for this LDAP data store. This is required if 'hostnames' is not provided.  # noqa: E501

        :param hostnames_tags: The hostnames_tags of this LdapDataStore.  # noqa: E501
        :type: list[LdapTagConfig]
        """

        self._hostnames_tags = hostnames_tags

    @property
    def hostnames(self):
        """Gets the hostnames of this LdapDataStore.  # noqa: E501

        The default LDAP host names. This field is required if no mapping for host names and tags is specified. Failover can be configured by providing multiple host names.  # noqa: E501

        :return: The hostnames of this LdapDataStore.  # noqa: E501
        :rtype: list[str]
        """
        return self._hostnames

    @hostnames.setter
    def hostnames(self, hostnames):
        """Sets the hostnames of this LdapDataStore.

        The default LDAP host names. This field is required if no mapping for host names and tags is specified. Failover can be configured by providing multiple host names.  # noqa: E501

        :param hostnames: The hostnames of this LdapDataStore.  # noqa: E501
        :type: list[str]
        """

        self._hostnames = hostnames

    @property
    def name(self):
        """Gets the name of this LdapDataStore.  # noqa: E501

        The data store name with a unique value across all data sources. Omitting this attribute will set the value to a combination of the hostname(s) and the principal.  # noqa: E501

        :return: The name of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name):
        """Sets the name of this LdapDataStore.

        The data store name with a unique value across all data sources. Omitting this attribute will set the value to a combination of the hostname(s) and the principal.  # noqa: E501

        :param name: The name of this LdapDataStore.  # noqa: E501
        :type: str
        """

        self._name = name

    @property
    def ldap_type(self):
        """Gets the ldap_type of this LdapDataStore.  # noqa: E501

        A type that allows PingFederate to configure many provisioning settings automatically. The 'UNBOUNDID_DS' type has been deprecated, please use the 'PING_DIRECTORY' type instead.  # noqa: E501

        :return: The ldap_type of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._ldap_type

    @ldap_type.setter
    def ldap_type(self, ldap_type):
        """Sets the ldap_type of this LdapDataStore.

        A type that allows PingFederate to configure many provisioning settings automatically. The 'UNBOUNDID_DS' type has been deprecated, please use the 'PING_DIRECTORY' type instead.  # noqa: E501

        :param ldap_type: The ldap_type of this LdapDataStore.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and ldap_type is None:
            raise ValueError("Invalid value for `ldap_type`, must not be `None`")  # noqa: E501
        allowed_values = ["ACTIVE_DIRECTORY", "ORACLE_DIRECTORY_SERVER", "ORACLE_UNIFIED_DIRECTORY", "UNBOUNDID_DS", "PING_DIRECTORY", "GENERIC"]  # noqa: E501
        if (self._configuration.client_side_validation and
                ldap_type not in allowed_values):
            raise ValueError(
                "Invalid value for `ldap_type` ({0}), must be one of {1}"  # noqa: E501
                .format(ldap_type, allowed_values)
            )

        self._ldap_type = ldap_type

    @property
    def bind_anonymously(self):
        """Gets the bind_anonymously of this LdapDataStore.  # noqa: E501

        Whether username and password are required. If true, no other authentication fields should be provided. The default value is false.  # noqa: E501

        :return: The bind_anonymously of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._bind_anonymously

    @bind_anonymously.setter
    def bind_anonymously(self, bind_anonymously):
        """Sets the bind_anonymously of this LdapDataStore.

        Whether username and password are required. If true, no other authentication fields should be provided. The default value is false.  # noqa: E501

        :param bind_anonymously: The bind_anonymously of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._bind_anonymously = bind_anonymously

    @property
    def user_dn(self):
        """Gets the user_dn of this LdapDataStore.  # noqa: E501

        The username credential required to access the data store. If specified, no other authentication fields should be provided.  # noqa: E501

        :return: The user_dn of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._user_dn

    @user_dn.setter
    def user_dn(self, user_dn):
        """Sets the user_dn of this LdapDataStore.

        The username credential required to access the data store. If specified, no other authentication fields should be provided.  # noqa: E501

        :param user_dn: The user_dn of this LdapDataStore.  # noqa: E501
        :type: str
        """

        self._user_dn = user_dn

    @property
    def password(self):
        """Gets the password of this LdapDataStore.  # noqa: E501

        The password credential required to access the data store. GETs will not return this attribute. To update this field, specify the new value in this attribute.  # noqa: E501

        :return: The password of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._password

    @password.setter
    def password(self, password):
        """Sets the password of this LdapDataStore.

        The password credential required to access the data store. GETs will not return this attribute. To update this field, specify the new value in this attribute.  # noqa: E501

        :param password: The password of this LdapDataStore.  # noqa: E501
        :type: str
        """

        self._password = password

    @property
    def encrypted_password(self):
        """Gets the encrypted_password of this LdapDataStore.  # noqa: E501

        The encrypted password credential required to access the data store.  If you do not want to update the stored value, this attribute should be passed back unchanged. Secret Reference may be provided in this field with format 'OBF:MGR:{secretManagerId}:{secretId}'.  # noqa: E501

        :return: The encrypted_password of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._encrypted_password

    @encrypted_password.setter
    def encrypted_password(self, encrypted_password):
        """Sets the encrypted_password of this LdapDataStore.

        The encrypted password credential required to access the data store.  If you do not want to update the stored value, this attribute should be passed back unchanged. Secret Reference may be provided in this field with format 'OBF:MGR:{secretManagerId}:{secretId}'.  # noqa: E501

        :param encrypted_password: The encrypted_password of this LdapDataStore.  # noqa: E501
        :type: str
        """

        self._encrypted_password = encrypted_password

    @property
    def client_tls_certificate_ref(self):
        """Gets the client_tls_certificate_ref of this LdapDataStore.  # noqa: E501

        The client TLS certificate used to access the data store. If specified, authentication to the data store will be done using mutual TLS and no other authentication fields should be provided. See '/keyPairs/sslClient' to manage certificates.  # noqa: E501

        :return: The client_tls_certificate_ref of this LdapDataStore.  # noqa: E501
        :rtype: ResourceLink
        """
        return self._client_tls_certificate_ref

    @client_tls_certificate_ref.setter
    def client_tls_certificate_ref(self, client_tls_certificate_ref):
        """Sets the client_tls_certificate_ref of this LdapDataStore.

        The client TLS certificate used to access the data store. If specified, authentication to the data store will be done using mutual TLS and no other authentication fields should be provided. See '/keyPairs/sslClient' to manage certificates.  # noqa: E501

        :param client_tls_certificate_ref: The client_tls_certificate_ref of this LdapDataStore.  # noqa: E501
        :type: ResourceLink
        """

        self._client_tls_certificate_ref = client_tls_certificate_ref

    @property
    def use_ssl(self):
        """Gets the use_ssl of this LdapDataStore.  # noqa: E501

        Connects to the LDAP data store using secure SSL/TLS encryption (LDAPS). The default value is false.  # noqa: E501

        :return: The use_ssl of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._use_ssl

    @use_ssl.setter
    def use_ssl(self, use_ssl):
        """Sets the use_ssl of this LdapDataStore.

        Connects to the LDAP data store using secure SSL/TLS encryption (LDAPS). The default value is false.  # noqa: E501

        :param use_ssl: The use_ssl of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._use_ssl = use_ssl

    @property
    def use_dns_srv_records(self):
        """Gets the use_dns_srv_records of this LdapDataStore.  # noqa: E501

        Use DNS SRV Records to discover LDAP server information. The default value is false.  # noqa: E501

        :return: The use_dns_srv_records of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._use_dns_srv_records

    @use_dns_srv_records.setter
    def use_dns_srv_records(self, use_dns_srv_records):
        """Sets the use_dns_srv_records of this LdapDataStore.

        Use DNS SRV Records to discover LDAP server information. The default value is false.  # noqa: E501

        :param use_dns_srv_records: The use_dns_srv_records of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._use_dns_srv_records = use_dns_srv_records

    @property
    def follow_ldap_referrals(self):
        """Gets the follow_ldap_referrals of this LdapDataStore.  # noqa: E501

        Follow LDAP Referrals in the domain tree. The default value is false. This property does not apply to PingDirectory as this functionality is configured in PingDirectory.  # noqa: E501

        :return: The follow_ldap_referrals of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._follow_ldap_referrals

    @follow_ldap_referrals.setter
    def follow_ldap_referrals(self, follow_ldap_referrals):
        """Sets the follow_ldap_referrals of this LdapDataStore.

        Follow LDAP Referrals in the domain tree. The default value is false. This property does not apply to PingDirectory as this functionality is configured in PingDirectory.  # noqa: E501

        :param follow_ldap_referrals: The follow_ldap_referrals of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._follow_ldap_referrals = follow_ldap_referrals

    @property
    def retry_failed_operations(self):
        """Gets the retry_failed_operations of this LdapDataStore.  # noqa: E501

        Indicates whether failed operations should be retried. The default is false.  # noqa: E501

        :return: The retry_failed_operations of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._retry_failed_operations

    @retry_failed_operations.setter
    def retry_failed_operations(self, retry_failed_operations):
        """Sets the retry_failed_operations of this LdapDataStore.

        Indicates whether failed operations should be retried. The default is false.  # noqa: E501

        :param retry_failed_operations: The retry_failed_operations of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._retry_failed_operations = retry_failed_operations

    @property
    def test_on_borrow(self):
        """Gets the test_on_borrow of this LdapDataStore.  # noqa: E501

        Indicates whether objects are validated before being borrowed from the pool.  # noqa: E501

        :return: The test_on_borrow of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._test_on_borrow

    @test_on_borrow.setter
    def test_on_borrow(self, test_on_borrow):
        """Sets the test_on_borrow of this LdapDataStore.

        Indicates whether objects are validated before being borrowed from the pool.  # noqa: E501

        :param test_on_borrow: The test_on_borrow of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._test_on_borrow = test_on_borrow

    @property
    def test_on_return(self):
        """Gets the test_on_return of this LdapDataStore.  # noqa: E501

        Indicates whether objects are validated before being returned to the pool.  # noqa: E501

        :return: The test_on_return of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._test_on_return

    @test_on_return.setter
    def test_on_return(self, test_on_return):
        """Sets the test_on_return of this LdapDataStore.

        Indicates whether objects are validated before being returned to the pool.  # noqa: E501

        :param test_on_return: The test_on_return of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._test_on_return = test_on_return

    @property
    def create_if_necessary(self):
        """Gets the create_if_necessary of this LdapDataStore.  # noqa: E501

        Indicates whether temporary connections can be created when the Maximum Connections threshold is reached.  # noqa: E501

        :return: The create_if_necessary of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._create_if_necessary

    @create_if_necessary.setter
    def create_if_necessary(self, create_if_necessary):
        """Sets the create_if_necessary of this LdapDataStore.

        Indicates whether temporary connections can be created when the Maximum Connections threshold is reached.  # noqa: E501

        :param create_if_necessary: The create_if_necessary of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._create_if_necessary = create_if_necessary

    @property
    def verify_host(self):
        """Gets the verify_host of this LdapDataStore.  # noqa: E501

        Verifies that the presented server certificate includes the address to which the client intended to establish a connection. Omitting this attribute will set the value to true.  # noqa: E501

        :return: The verify_host of this LdapDataStore.  # noqa: E501
        :rtype: bool
        """
        return self._verify_host

    @verify_host.setter
    def verify_host(self, verify_host):
        """Sets the verify_host of this LdapDataStore.

        Verifies that the presented server certificate includes the address to which the client intended to establish a connection. Omitting this attribute will set the value to true.  # noqa: E501

        :param verify_host: The verify_host of this LdapDataStore.  # noqa: E501
        :type: bool
        """

        self._verify_host = verify_host

    @property
    def min_connections(self):
        """Gets the min_connections of this LdapDataStore.  # noqa: E501

        The smallest number of connections that can remain in each pool, without creating extra ones. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The min_connections of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._min_connections

    @min_connections.setter
    def min_connections(self, min_connections):
        """Sets the min_connections of this LdapDataStore.

        The smallest number of connections that can remain in each pool, without creating extra ones. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param min_connections: The min_connections of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._min_connections = min_connections

    @property
    def max_connections(self):
        """Gets the max_connections of this LdapDataStore.  # noqa: E501

        The largest number of active connections that can remain in each pool without releasing extra ones. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The max_connections of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._max_connections

    @max_connections.setter
    def max_connections(self, max_connections):
        """Sets the max_connections of this LdapDataStore.

        The largest number of active connections that can remain in each pool without releasing extra ones. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param max_connections: The max_connections of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._max_connections = max_connections

    @property
    def max_wait(self):
        """Gets the max_wait of this LdapDataStore.  # noqa: E501

        The maximum number of milliseconds the pool waits for a connection to become available when trying to obtain a connection from the pool. Omitting this attribute or setting a value of -1 causes the pool not to wait at all and to either create a new connection or produce an error (when no connections are available).  # noqa: E501

        :return: The max_wait of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._max_wait

    @max_wait.setter
    def max_wait(self, max_wait):
        """Sets the max_wait of this LdapDataStore.

        The maximum number of milliseconds the pool waits for a connection to become available when trying to obtain a connection from the pool. Omitting this attribute or setting a value of -1 causes the pool not to wait at all and to either create a new connection or produce an error (when no connections are available).  # noqa: E501

        :param max_wait: The max_wait of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._max_wait = max_wait

    @property
    def time_between_evictions(self):
        """Gets the time_between_evictions of this LdapDataStore.  # noqa: E501

        The frequency, in milliseconds, that the evictor cleans up the connections in the pool. A value of -1 disables the evictor. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The time_between_evictions of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._time_between_evictions

    @time_between_evictions.setter
    def time_between_evictions(self, time_between_evictions):
        """Sets the time_between_evictions of this LdapDataStore.

        The frequency, in milliseconds, that the evictor cleans up the connections in the pool. A value of -1 disables the evictor. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param time_between_evictions: The time_between_evictions of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._time_between_evictions = time_between_evictions

    @property
    def read_timeout(self):
        """Gets the read_timeout of this LdapDataStore.  # noqa: E501

        The maximum number of milliseconds a connection waits for a response to be returned before producing an error. A value of -1 causes the connection to wait indefinitely. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The read_timeout of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._read_timeout

    @read_timeout.setter
    def read_timeout(self, read_timeout):
        """Sets the read_timeout of this LdapDataStore.

        The maximum number of milliseconds a connection waits for a response to be returned before producing an error. A value of -1 causes the connection to wait indefinitely. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param read_timeout: The read_timeout of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._read_timeout = read_timeout

    @property
    def connection_timeout(self):
        """Gets the connection_timeout of this LdapDataStore.  # noqa: E501

        The maximum number of milliseconds that a connection attempt should be allowed to continue before returning an error. A value of -1 causes the pool to wait indefinitely. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The connection_timeout of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._connection_timeout

    @connection_timeout.setter
    def connection_timeout(self, connection_timeout):
        """Sets the connection_timeout of this LdapDataStore.

        The maximum number of milliseconds that a connection attempt should be allowed to continue before returning an error. A value of -1 causes the pool to wait indefinitely. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param connection_timeout: The connection_timeout of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._connection_timeout = connection_timeout

    @property
    def dns_ttl(self):
        """Gets the dns_ttl of this LdapDataStore.  # noqa: E501

        The maximum time in milliseconds that DNS information are cached. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The dns_ttl of this LdapDataStore.  # noqa: E501
        :rtype: int
        """
        return self._dns_ttl

    @dns_ttl.setter
    def dns_ttl(self, dns_ttl):
        """Sets the dns_ttl of this LdapDataStore.

        The maximum time in milliseconds that DNS information are cached. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param dns_ttl: The dns_ttl of this LdapDataStore.  # noqa: E501
        :type: int
        """

        self._dns_ttl = dns_ttl

    @property
    def ldap_dns_srv_prefix(self):
        """Gets the ldap_dns_srv_prefix of this LdapDataStore.  # noqa: E501

        The prefix value used to discover LDAP DNS SRV record. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The ldap_dns_srv_prefix of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._ldap_dns_srv_prefix

    @ldap_dns_srv_prefix.setter
    def ldap_dns_srv_prefix(self, ldap_dns_srv_prefix):
        """Sets the ldap_dns_srv_prefix of this LdapDataStore.

        The prefix value used to discover LDAP DNS SRV record. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param ldap_dns_srv_prefix: The ldap_dns_srv_prefix of this LdapDataStore.  # noqa: E501
        :type: str
        """

        self._ldap_dns_srv_prefix = ldap_dns_srv_prefix

    @property
    def ldaps_dns_srv_prefix(self):
        """Gets the ldaps_dns_srv_prefix of this LdapDataStore.  # noqa: E501

        The prefix value used to discover LDAPs DNS SRV record. Omitting this attribute will set the value to the default value.  # noqa: E501

        :return: The ldaps_dns_srv_prefix of this LdapDataStore.  # noqa: E501
        :rtype: str
        """
        return self._ldaps_dns_srv_prefix

    @ldaps_dns_srv_prefix.setter
    def ldaps_dns_srv_prefix(self, ldaps_dns_srv_prefix):
        """Sets the ldaps_dns_srv_prefix of this LdapDataStore.

        The prefix value used to discover LDAPs DNS SRV record. Omitting this attribute will set the value to the default value.  # noqa: E501

        :param ldaps_dns_srv_prefix: The ldaps_dns_srv_prefix of this LdapDataStore.  # noqa: E501
        :type: str
        """

        self._ldaps_dns_srv_prefix = ldaps_dns_srv_prefix

    @property
    def binary_attributes(self):
        """Gets the binary_attributes of this LdapDataStore.  # noqa: E501

        The list of LDAP attributes to be handled as binary data.  # noqa: E501

        :return: The binary_attributes of this LdapDataStore.  # noqa: E501
        :rtype: list[str]
        """
        return self._binary_attributes

    @binary_attributes.setter
    def binary_attributes(self, binary_attributes):
        """Sets the binary_attributes of this LdapDataStore.

        The list of LDAP attributes to be handled as binary data.  # noqa: E501

        :param binary_attributes: The binary_attributes of this LdapDataStore.  # noqa: E501
        :type: list[str]
        """

        self._binary_attributes = binary_attributes

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LdapDataStore, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LdapDataStore):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, LdapDataStore):
            return True

        return self.to_dict() != other.to_dict()
